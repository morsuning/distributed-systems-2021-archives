6.824 2020 第11讲：链式复制

支持高吞吐量和可用性的链式复制
(OSDI 2004) 作者 Renesse 和 Schneider

背景：复制状态机
  两种主要方法：
  1. 通过Paxos/Raft运行所有操作
    相对不常见的方法但参见Spanner（和实验3）
    性能具有挑战性，特别是如果数据很大
  2. 配置服务器加上主控/备份复制
    例如：GFS，主控加上块的P/B复制
    例如：VM-FT，测试和设置服务器加上P/B复制

链式复制（CR）
  这篇论文关于如何为方法2做P/B复制
  - 涵盖故障转移
  有影响力：许多基于CR构建
    Ceph、Parameter Server、COPS、FAWN。

什么是链式复制（CR）？
  目标：如果客户端获得写入回复，即使只有一个服务器存活，数据也是安全的。
         并且是线性化的。
  S1, S2, S3, S4
  S1是"头部"
  S4是"尾部"
  写入：
    客户端发送到头部
    沿链转发，按顺序
    每个服务器用新数据覆盖旧数据
    尾部响应客户端
  读取：
    客户端发送到尾部
    尾部响应（不涉及其他节点）

配置服务的角色
 配置服务监控服务器
 如果服务器不可达：
   配置创建新配置并通知客户端和服务器
   此期间没有服务
 配置服务避免脑裂

让客户端读取CR中的任何副本会是正确的（线性化的）吗？
  不。
  读取可能看到未提交的数据，可能由于故障而消失。
  客户端可能从一个副本看到一个新值，
    然后从不同（稍后）的副本看到一个旧值。
因此，只从尾部读取

讲座问题：给出一个示例场景，如果链的头部在收到链中下一个服务器的确认后立即向客户端返回响应（而不是尾部响应），客户端可能观察到不正确的结果（即，非线性化的）。

CR线性化的直觉？
  当没有故障时，几乎好像尾部是唯一的服务器。
    头部为写入选择顺序，副本按该顺序应用，
      所以除了最近（未提交）的写入外，它们将保持同步。
    尾部只向读取者暴露已提交的写入。

故障恢复，简要说明。
  好消息：每个副本都知道每个已提交的写入。
  但需要将部分写入推下链。
  如果头部失败，后继者接管作为头部，没有提交的写入丢失。
  如果尾部失败，前任者接管作为尾部，没有写入丢失。
  如果中间失败，从链中删除，前任者可能需要重新发送最近的写入。

添加服务器
  扩展尾部，简要说明：
    将尾部状态复制到新服务器
      复制进行时尾部记录更新
    新服务器告诉尾部它不再是尾部
      尾部将所有记录的更新发送到新服务器
      新服务器告诉配置服务器，它是尾部
    新服务器开始服务请求
      旧尾部重定向客户端请求

为什么CR有吸引力（相比Raft）？
  客户端RPC在头部和尾部之间分配，相比Raft的领导者处理两者。
  头部只发送每个写入一次，相比Raft的领导者发送给所有。
  读取只涉及一个服务器，而不是像Raft中的所有服务器。
    或者使用Raft读取优化的多数
  故障后的情况比Raft简单（记住图7）。
    [考虑一些场景]

为什么让客户端读取CR中的任何副本有吸引力？
  机会是中间副本在读取负载足够高以至于尾部饱和时可能仍然有备用CPU周期。
  将读取负载从尾部移动到中间节点
    因此可能在饱和的链上产生更高的读取吞吐量。
  CR论文描述了实现这一目标的一种方法：
    将对象分割到许多链，每个服务器参与多个链。
    C1: S1 S2 S3
    C2: S2 S3 S1
    C3: S3 S1 S2
  如果负载在链之间或多或少均匀分配，这工作正常。
  通常不是。
    也许你可以将对象分割到更多链。

为什么CR可以从副本线性化地服务读取而Raft/ZooKeeper/等不能？
  依赖于是一个链，所以*所有*节点在写入提交之前看到每个
    写入，所以节点知道
    所有可能已提交的写入，因此知道何时
    询问尾部。
  Raft/ZooKeeper不能这样做，因为领导者可以仅用
    多数继续，所以可以在所有跟随者看到写入之前提交，
    所以跟随者不知道它们何时错过了已提交的写入。

这是否意味着CR严格比Raft等更强大？
  不。
  所有CR副本都必须参与才能提交任何写入。
  如果节点不可达，CR必须等待。
  所以不像ZK和Raft那样立即可容错。

等效地，如果第二个节点无法到达头部，为什么它不能接管作为头部？
  分区——脑裂——第二个节点必须耐心等待。

我们如何安全使用无法处理分区的复制系统？
  单个"配置管理器"必须选择头部、链、尾部。
  每个人（服务器、客户端）必须服从或停止。
    无论他们本地认为谁存活/死亡。
  配置管理器是一个常见且有用的模式。
    这是GFS（主控）和VMware-FT（测试和设置服务器）工作的本质。
    通常配置服务使用Paxos/Raft/ZK，
      数据分片到许多副本组，
      每个副本组使用CR或其他快速方法。
    实验4以这种方式工作（虽然一切都是Raft）。