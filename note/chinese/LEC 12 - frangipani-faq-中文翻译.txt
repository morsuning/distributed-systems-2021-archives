Frangipani 常见问题解答，Thekkath, Mann, Lee, SOSP 1997

问：我们为什么要读这篇论文？

答：主要是作为缓存一致性的一个例子。

但还有其他有趣的方面。每个客户端拥有自己的日志，存储在一个公共地方，以便任何人都可以从中恢复，这个想法很巧妙。此外，日志以一种不寻常的方式交织在一起：对给定对象的更新可能分散在多个日志中。这使得重放单个日志变得棘手（因此有了 Frangipani 的版本号机制）。从简单的共享存储（Petal）和智能但去中心化的参与者构建系统很有趣，特别是从单个参与者崩溃中恢复。

问：Frangipani 与 GFS 有何不同？

答：一个大的架构差异是 GFS 将大部分文件系统逻辑放在服务器中，而 Frangipani 将逻辑分布在运行 Frangipani 的工作站上。也就是说，Frangipani 并不像 GFS 那样有真正的文件服务器概念，只有文件客户端。Frangipani 将文件系统逻辑放在客户端中，以允许它们纯粹在本地缓存中执行文件系统操作。当大多数活动是客户端工作站读写单个用户的（缓存）文件时，这是合理的。Frangipani 有大量机制来确保工作站缓存保持一致，既确保一个工作站上的写入对另一个工作站上的读取立即可见，也确保复杂操作（如创建文件）是原子的，即使其他工作站正在尝试查看相关文件或目录。后一种情况对 Frangipani 来说很棘手，因为没有指定的文件服务器来执行对给定文件或目录的所有操作。

相比之下，GFS 根本没有缓存，因为它的重点是顺序读写那些太大而无法放入任何缓存的巨型文件。它通过将每个文件分条到多个 GFS 服务器上来获得对巨型文件读取的高性能。因为 GFS 没有缓存，所以 GFS 没有缓存一致性协议。因为文件系统逻辑在服务器中，GFS 客户端相对简单；只有服务器需要加锁并担心崩溃恢复。

Frangipani 作为一个真正的文件系统出现，你可以与任何现有的工作站程序一起使用。GFS 在那种意义上不呈现为文件系统；应用程序必须明确编写以通过库调用使用 GFS。

问：为什么 Frangipani 系统中的 Petal 服务器有块接口？为什么没有像 AFS 那样了解目录和文件等事物的文件服务器？

一个原因是作者首先开发了 Petal。Petal 已经解决了许多容错和扩展问题，因此使用它简化了 Frangipani 设计的某些方面。而且这种安排将工作从中央服务器转移到客户端工作站，这有助于 Frangipani 性能在添加更多工作站时良好扩展。

然而，Petal/Frangipani 分割使得在文件系统级别结构上强制执行不变量更加困难，因为没有单一实体负责。Frangipani 构建了自己的事务系统（使用锁服务和 Frangipani 的日志），以便能够对存储在 Petal 中的文件系统进行复杂的原子更新。

问：运行 Frangipani 的工作站会破坏安全性吗？

答：会。由于文件系统逻辑在客户端工作站中，设计将信任放在客户端中。用户可以修改本地 Frangipani 软件并在 Petal 中读写其他用户的数据。如果用户不受信任，这使得 Frangipani 没有吸引力。它可能在小型组织中有意义，或者如果 Frangipani 在独立的专用服务器上运行（而不是在工作站上），并通过像 NFS 这样的协议与用户工作站通信。

问：什么是数字设备公司（DEC）？

答：这是作者工作的公司。DEC 销售计算机和系统软件。Unix 最初是在 DEC 硬件上开发的（虽然在贝尔实验室，而不是在数字公司）。

问：第 9.2 节中的注释"文件创建需要更长时间..."是什么意思？

答：由于日志记录，所有元数据更改都必须写入 Petal 两次：一次写入日志，一次写入文件系统。操作必须首先写入日志（因此是"预写日志"）。然后可以写入磁盘上的文件系统结构。只有在那之后才能从日志中删除操作。也就是说，只有在日志中部分的所有操作的磁盘文件系统更新都已写入 Petal 后，才能释放该日志部分。

所以当 Frangipani 的日志填满时，Frangipani 必须停止处理新操作，将其缓存中的修改块发送到 Petal，用于它想要重用的日志部分中的操作，然后释放该部分并恢复处理新操作。

你可能想知道为什么增加日志大小会提高性能。毕竟，无论日志多长，Frangipani 都必须执行对 Petal 中文件系统的更新，而这些更新似乎是限制性能的因素。这是一个猜测。可能是基准测试涉及多次更新同一个目录，以向该目录添加新文件。每次释放部分日志时都必须将该目录的块写入 Petal（假设每次创建都修改该目录）。因此让日志增长更长时间减少了基准测试期间该目录必须写入 Petal 的总次数，这减少了基准测试运行时间。这种效应称为"写吸收"。

问：Frangipani 现在已经超过 20 年了；分布式文件系统的最新技术是什么？

答：虽然今天一些组织将用户和项目文件存储在分布式文件系统上，但随着笔记本电脑（必须是自包含的）和商业云服务的兴起，它们的重要性已经下降。仍然有许多现有文件系统协议的用户，如 SMB、NFS 和 AFS，以及更近期的分布式文件系统，如 xtreemfs、Ceph、Lustre 和 Dropbox。像 NetAPP 和 EMC 这样的公司销售了大量网络存储，但我不知道人们在多大程度上在磁盘级别使用存储（例如通过 iSCSI）或作为文件服务器（例如通过 NFS 与 NetAPP 服务器通信）。

网站、大数据和云计算的兴起已经转移了存储系统开发的重点。网站与数据库式服务器配合良好，包括键/值存储；文件服务器在这里不太匹配。大数据处理系统经常使用文件系统，例如 MapReduce 的 GFS，但重点是巨型文件的高并行吞吐量；Frangipani 的缓存、一致性和加锁不需要。

问：论文说 Frangipani 只为自己的文件系统元数据（i-node、目录、空闲位图）进行崩溃恢复，而不为用户的文件内容进行恢复。这是什么意思，为什么是 OK 的？

答：如果工作站上的用户向 Frangipani 上的文件写入一些数据，然后工作站立即崩溃，最近写入的数据可能会丢失。也就是说，如果用户登录到另一个工作站并查看该文件，最近写入的数据可能丢失。

普通的 Unix 文件系统（例如笔记本电脑上的 Linux）有相同的属性：在崩溃前刚刚写入的文件内容可能会丢失。

关心崩溃恢复的程序（例如文本编辑器和数据库）可以要求 Unix 更小心，以一定的性能代价。特别是，应用程序可以调用 fsync()，它告诉 Unix 立即将数据强制到磁盘，以便它能在崩溃中幸存。论文在第 2.1 节提到了 fsync()。

这里的理由是文件系统小心地维护自己的内部不变量（在自己的元数据上），否则文件系统在崩溃后可能根本不可用。但文件系统将维护文件内容不变量留给应用程序，因为只有应用程序知道哪些数据必须小心地（并且昂贵地）立即写入磁盘。

问：存储在 Frangipani 工作站中的日志和存储在 Petal 中的日志有什么区别？

Petal 论文几乎根本没有提到 Petal 的日志。我猜测 Petal 记录从逻辑块号到物理块号的映射更改、物理块空闲列表的更改，以及指示该块的其他副本可能缺少哪些块更新的"忙"位的更改。也就是说，Petal 记录关于低级块操作的信息。

Frangipani 记录关于文件系统操作的信息，这些操作通常涉及更新 Petal 中的多个文件系统状态部分。例如，删除文件的 Frangipani 日志条目可能说删除操作修改了某些块和 i-node 空闲位图位，并且操作擦除了特定的目录条目。

两个日志都存储在 Petal 的磁盘上。从 Petal 的角度来看，Frangipani 的日志只是存储在 Petal 块中的数据；Petal 对 Frangipani 的日志没有任何特殊了解。

问：Petal 如何有效地拍摄它表示的大虚拟磁盘的快照？

答：Petal 维护从虚拟块号到物理块号的映射。映射实际上由一对索引：虚拟块号和时期号。还有当前时期号的概念。当 Petetal 执行对虚拟块的写入时，它查看当前映射的时期号；如果时期号小于当前时期号，Petal 创建一个具有当前时期的新映射（并分配新的物理块）。对虚拟块的读取使用具有最高时期的映射。

创建快照然后只需要增加当前时期号。从快照读取需要指定快照的时期号；然后每次读取使用对请求的虚拟块号具有最高时期号 <= 快照时期的映射。

看看 Petal 论文的第 2.2 节：

http://www.scs.stanford.edu/nyu/02fa/sched/petal.pdf

问：论文说 Frangipani 不立即将新日志条目发送到 Petal。如果工作站在系统调用完成后但在将相应日志条目发送到 Petal 之前崩溃，会发生什么？

答：假设运行在 Frangipani 工作站上的应用程序创建一个文件。一段时间，关于新创建文件的信息只存在于该工作站的缓存（RAM）中。如果工作站在将信息写入 Petal 之前崩溃，新文件完全丢失。它不会被恢复。

所以看起来像这样的应用程序：

  创建文件 x；
  打印"我创建了文件 x"；

可能会打印"我创建了文件 x"，但是（如果它然后崩溃）文件 x 可能不存在。

这可能看起来不幸，但即使是本地磁盘文件系统（如 Linux）也相当常见。需要确保其数据真正永久保存的应用程序可以调用 fsync()。

问：分条文件是什么意思？这与分片类似吗？

答：与分片类似。更具体地说，它意味着将单个文件的块分布在多个服务器上（对于本文是 Petal 服务器），以便（例如）文件的块 0 放在服务器 0 上，块 1 放在服务器 1 上，块 2 放在服务器 0 上，块 3 放在服务器 1 上，等等。这样做的一个原因是为了获得对单个大文件的读取高性能，因为同一文件的不同部分可以从不同的服务器/磁盘读取。另一个原因是确保在服务器之间均匀平衡负载。

问：论文中提到的"伪共享"问题是什么？

答：系统以 512 字节块的粒度读写 Petal。如果它将不相关的项目 X 和 Y 存储在同一个 512 字节块上，一个工作站需要修改 X，而另一个需要修改 Y，它们将不得不在它们之间来回传递单个块的副本。因为没有办法要求 Petetal 一次写入少于 512 字节。这是共享，因为两个工作站使用同一个块；这是伪的，因为它们从根本上不需要。

问：我不理解第 4 节关于 Frangipani 如何强制执行更强条件的文本，即从不重放已完成的更新。

这是问题的一个例子。假设工作站 WS1 创建文件 xxx，然后删除它。之后，不同的工作站 WS2 创建文件 xxx。它们的日志将如下所示：

WS1:  create(xxx)  delete(xxx)
WS2:                           create(xxx)

此时，正确性要求 xxx 存在（因为 WS2 的创建在 WS1 的删除之后）。

现在假设 WS1 崩溃，Frangipani 恢复重放 WS1 的日志。恢复将看到日志中的 delete(xxx) 操作。我们知道实际执行删除将是不正确的，因为我知道 WS2 的 create(xxx) 在 WS1 的 delete(xxx) 之后。但是 Frangipani 的恢复软件如何得出结论在重放 WS1 日志时应该忽略 delete(xxx)？

第 4 节说 Frangipani 的恢复软件知道忽略 delete(xxx)，因为它"从不重放描述已经完成的更新的日志记录"。它通过在每个元数据块和每个日志条目中保持版本号来实现这个属性；如果日志条目的版本号 <= 元数据块的版本号，Frangipani 恢复知道元数据块已经被日志条目更新，因此应该忽略该日志条目。

问：通过为每个文件中的每个块设置单独的锁，Frangipani 可以获得多少性能改进？

答：可能对性能有害。这可能意味着读取文件需要获取每个块的锁——因此工作站和锁服务器要做更多的工作。而且实践中可能没有好处，因为很少有应用程序在文件块级别进行读/写共享，因此可以从不同工作站同时修改同一文件的不同块中受益。在完整文件级别的共享更常见——比如当你的编辑器写出整个文件，然后你的编译器读取整个文件。

问：Frangipani 和两阶段提交系统都提供分布式事务。它们是等价的吗——可以将 Frangipani 视为埋藏着两阶段提交吗？或者有显著差异？

Frangipani 和两阶段提交有相似之处。在两种情况下，为了执行操作，必须获取所有相关锁，必须收集所有相关数据，必须记录所有内容，然后才能释放锁。最大的区别是这些事情发生的地方。在 Frangipani 中，锁和数据是可移动的，并被收集在执行操作的 Frangipani 服务器上。在两阶段提交中，数据（带有关联锁和日志）分布在服务器上，所以工作必须以相同方式分割。

一个显著的区别是 Frangipani 有一个关于如果服务器在持有锁时崩溃如何继续的故事——每个 Frangipani 服务器的日志在 Petal 中，所以其他服务器可以为它恢复。经典的两阶段提交将服务器的日志放在其本地磁盘上，所以如果服务器崩溃就无法访问，所以无法取得进展（并且锁不能释放），直到服务器重新启动。

恢复的另一种方法是使用例如 Paxos 复制每个参与的两阶段提交服务器（包括锁、日志和数据），有效地消除崩溃服务器的担忧。Spanner 这样做。