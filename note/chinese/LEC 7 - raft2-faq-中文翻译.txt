Raft (2) FAQ

问：除了GFS主控复制，Raft还有哪些用途？

答：你可以（并且将要）使用Raft构建容错的键值数据库。

你可以使用Raft使MapReduce主控容错。

你可以构建容错锁定服务。


问：当raft接收到读请求时，它是否仍然提交一个无操作？

答：第8节提到了两种不同的方法。领导者可以先发送心跳；或者可以有一个约定，领导者在每次心跳后的一段时间内不能改变（租约）。真实系统通常使用租约，因为它需要更少的通信。

第8节说领导者只在其任期开始时提交一个无操作。


问：论文指出读操作不需要日志写入，但接着立即引入提交无操作作为获取已提交的技术。这是一个矛盾还是无操作不被视为日志"写入"？

答：无操作只在任期开始时发生，而不是针对每次读操作。


问：我发现关于领导者需要提交一个无操作条目以了解哪些条目已提交的这行话很令人困惑。为什么它需要这样做？

答：问题情况如图8所示，如果S1在(b)之后成为领导者，它无法知道其最后一个日志条目(2)是否已提交。最后一个日志条目最终未提交的情况是，如果S1立即失败，S5是下一个领导者；在这种情况下，S5将强制所有同伴（包括S1）拥有与S5日志相同的日志，该日志不包括条目2。

但假设S1在其任期内成功提交了一个新条目（任期4）。如果S5看到新条目，S5将从其日志中擦除3并接受2。如果S5没有看到新条目，如果S1失败，S5不能成为下一个领导者，因为它将无法通过选举限制。无论哪种方式，一旦S1为其任期提交了一个新条目，它就可以正确地得出结论，其日志中每个前面的条目都已提交。

第8节末尾的无操作文本讨论的是一种优化，其中领导者执行和回答只读命令（例如get("k1")）而不在日志中提交这些命令。例如，对于get("k1")，领导者只需在其键值表中查找"k1"并将结果发送回客户端。如果领导者刚刚启动，它可能在日志末尾有一个put("k1", "v99")。领导者是否应该将"v99"发送回客户端，还是发送领导者键值表中的值？起初，领导者不知道该v99日志条目是否已提交（必须返回给客户端）或未提交（绝不能发回）。所以（如果你使用这种优化）新的Raft领导者首先尝试向日志提交一个无操作；如果提交成功（即领导者不崩溃），那么领导者知道该点之前的所有内容都已提交。


问：使用心跳机制为（只读）操作提供租约是如何工作的，为什么这需要定时来确保安全性（例如有界时钟偏差）？

答：我不知道作者的确切想法。也许领导者发送的每个AppendEntries RPC都说明或暗示在接下来的100毫秒内不允许选举其他领导者。如果领导者获得多数响应，那么领导者可以在接下来的100毫秒内提供只读请求，而无需与跟随者进一步通信。

这要求服务器对100毫秒的含义有相同的定义，即它们必须有以接近相同速率滴答的时钟。


问：第6节（和图11）中的C_old和C_new变量究竟代表什么？它们是每个配置中的领导者吗？

答：它们是旧/新配置中的服务器集合。

论文没有提供细节。我相信是服务器的身份（网络名称或地址）。


问：当从集群C_old转换到集群C_new时，我们如何创建混合集群C_{old,new}？我不太明白这意味着什么。它不是遵循C_old或C_new的网络配置吗？如果两个网络在连接上不同意怎么办？

答：在联合共识期间（当Cold,new处于活动状态时），领导者需要从Cold和Cnew中的服务器都获得多数。

实际上不可能有分歧，因为在Cold,new被提交到Cold和Cnew的日志中后（即在联合共识期间开始后），Cold或Cnew中的任何新领导者都保证看到Cold,Cnew的日志条目。


问：我对论文中的图11感到困惑。我不确定从'C_old'到'C_old,new'到'C_new'的转换是如何进行的。为什么存在集群领导者不属于新配置的问题，领导者在提交'C_new'日志条目后退位？（第6节提到的第二个问题）

答：假设C_old={S1,S2,S3}，C_new={S4,S5,S6}，S1在配置更改开始时是领导者。在配置更改结束时，S1提交C_new后，S1不应该再参与，因为S1不在C_new中。S4、S5或S6中的一个应该接管成为领导者。


问：关于集群配置：在配置更改期间，如果我们必须停止接收来自客户端的请求，那么拥有这种自动化配置步骤有什么意义？仅仅1)停止接收请求 2)更改配置 3)重启系统并继续就足够了吗？

答：这里的挑战是确保系统即使在此过程中有故障也是正确的，即使不是所有服务器同时获得"停止接收请求"和"更改配置"命令。任何方案都必须处理混合的服务器，这些服务器可能已经看到或完成配置更改，也可能没有——即使是非自动化系统也是如此。论文的协议是解决这个问题的一种方法。


问：第6节的最后两段讨论了已移除的服务器试图被选举而干扰集群的问题。
更简单的解决方案不是要求服务器在离开配置时关闭吗？离开集群似乎意味着服务器不能再向集群其余部分发送或接收RPC，但论文不假设这种情况。为什么不呢？为什么你不能假设服务器会立即关闭？

答：我认为直接的问题是第6节协议不向旧服务器提交Cnew，它只向Cnew中的服务器提交Cnew。所以不在Cnew中的服务器永远不知道Cnew何时从Cold,new接管。

论文确实这样说：

  当新配置在Cnew规则下提交时，旧配置无关紧要，不在新配置中的服务器可以关闭。

所以也许问题只存在于配置更改和管理员关闭旧服务器之间的时间段。我不知道为什么他们没有更自动化的方案。


问：在做选举和条目提交之类的事情时，从旧配置和新配置都获得多数有多常见？如果不常见，这对性能有多大的影响？

答：我想象在大多数情况下没有故障，领导者立即获得两个多数。配置更改可能只需要几个往返时间，即几十毫秒，所以获得两个多数的要求只会使系统慢下来一小段时间。配置更改可能不常见（也许每隔几个月）；每隔几十毫秒的延迟似乎不是高代价。


问：拥有两个多数的决定有多重要？

答：两个多数的要求对正确性是必需的，以覆盖领导者在配置更改期间失败的可能性。


问：明确说，让新成员作为非投票实体加入的过程不是为了加速日志复制过程，而是为了影响选举过程？这如何增加可用性？这些需要追赶的服务器无论如何都不会可用，对吗？


答：非投票服务器的目的是允许这些服务器获得领导者日志的完整副本，而不会阻止新提交。要点是允许后续配置更改很快。如果新服务器还没有几乎完整的日志，那么领导者将无法提交Cold,new，直到它们赶上；并且在Cold,new首次发出和提交时间之间不能执行新的客户端命令。


问：如果集群领导者没有新配置，为什么它在提交C_new时不将自己从多数中移除，然后在完成后返回成为领导者？需要新的选举过程吗？


答：这是关于第6节中的"第二个问题"吗？他们描述的情况是领导者根本不在新配置中。所以在Cnew提交后，领导者根本不应该参与Raft。


问：非投票成员状态在Raft的配置更改部分如何工作。该服务器状态只在转换期间（即c_new未提交时）持续，还是服务器只有在完全"追上"后才获得完整的投票特权？如果是这样，在什么点它们被认为是"追上"？

答：论文在这里没有太多细节。我想象领导者不会在要添加的服务器（非投票成员）几乎完全追上之前开始配置更改。当领导者在AppendEntries RPC中向那些新服务器发送Cold,new日志条目时，领导者将使它们完全更新（使用图2机制）。直到那些新服务器的大部分完全追上，领导者才能提交Cold,new消息。一旦Cold,new消息提交，那些新服务器就可以投票。


问：我不否认让服务器拒绝小于上次心跳以来最小选举超时的RequestVote是个好主意（它有助于防止不必要的选举），但他们为什么特别选择这种方法来防止不在配置中的服务器运行选举？似乎检查给定服务器是否在当前配置中更有意义。例如，在我们使用的实验代码中，每个服务器都有所有服务器的RPC地址（在当前配置中？），所以应该能够检查requestVote RPC是否来自有效（在配置中）的服务器，不是吗？

问：我同意论文的设计似乎有点笨拙，我不知道他们为什么那样设计。你的想法似乎是一个合理的起点。一个复杂情况是，可能存在Cnew中的服务器在联合共识阶段是领导者的情况，但此时Cold中的某些服务器可能不知道联合共识阶段（即它们只知道Cold，不知道Cold,new）；我们不希望后者的服务器忽略合法的领导者。


问：联合共识何时开始，何时结束？联合共识是否在"C_{o,n}"的提交时间开始？

答：当当前领导者知道Cold,new时，联合共识正在进行中。如果领导者没有设法提交Cold,new并崩溃，而新领导者在其日志中没有Cold,new，那么联合共识提前结束。如果领导者设法提交Cold,new，那么联合共识不仅已经开始，而且最终会在领导者提交Cnew时完成。


问：配置日志条目可以被后续领导者覆盖（假设该日志条目尚未提交）吗？

答：是的，这是可能的，如果原始领导者在提交Cold,new之前崩溃。


问："C_{o,n}"日志条目如何能被提交？它似乎必须被复制到"旧"服务器的多数（以及"新"服务器），但"C_{o,n}"的追加立即将旧服务器转换为新服务器，对吗？

答：提交不会改变Cold或Cnew中的服务器集合。例如，也许原始配置包含服务器S1、S2、S3；那么Cold是{S1,S2,S3}。也许期望的配置是S4、S5、S6；那么Cnew是{S4,S5,S6}。一旦Cnew提交到日志，配置就是Cnew={S4,S5,S6}；S1、S2和S3不再属于配置。


问：创建快照时，使用的数据和状态是用于客户端应用程序的吗？如果是客户端的数据，那么这是否是客户端本身需要支持的东西，除了raft论文中提到的修改？

答：示例：如果你正在构建一个使用Raft复制的键值服务器，那么服务器中会有一个键值模块，存储键值表。就是那个键值表保存在快照中。


问：论文说"如果跟随者接收到描述其日志前缀的快照，那么快照覆盖的日志条目被删除但快照之后的条目被保留"。这意味着我们可能正在删除状态机上的操作。

答：我不认为信息会丢失。如果快照覆盖日志的前缀，那意味着快照包括该前缀中所有操作的效果。所以丢弃该前缀是可以的。


问：当快照比应用更新序列小很多时（例如，对少数键的频繁更新），快照似乎很有用。当快照与其更新的总和一样大时（例如，每个更新插入一个新的唯一键）会发生什么？在这种情况下做快照有什么成本节约吗？

答：如果快照和日志差不多大，那么拥有快照可能没有太多价值。另一方面，也许快照以比日志更容易访问的方式组织数据，例如在排序表中。那么从快照表崩溃+重启后重新启动服务可能比从日志（你必须排序）更快。

然而，更典型的情况是日志比状态大得多。


问：InstallSnapshot也不会产生巨大的带宽成本吗？

答：是的，如果状态很大（例如数据库会是这样）。然而，这不是一个容易解决的问题。你可能希望领导者保留足够的日志来覆盖跟随者滞后或暂时离线的所有常见情况。你可能还想要一种只传输服务器状态差异的方法，例如只传输数据库中最近更改的部分。


问：是否有担心写入快照可能需要比选举超时更长的时间，因为需要追加到日志的数据量？

答：你说得对，对于大型服务器来说这是一个潜在问题。例如，如果你正在复制一个具有千兆字节数据的数据库，而你的磁盘只能以100兆字节每秒的速度写入，写入快照将需要十秒。一种可能性是在后台写入快照（即安排不等待写入，也许通过从子进程写入），并确保快照创建频率低于每十秒一次。


问：在什么情况下跟随者会接收到自己日志前缀的快照？

答：网络可能无序传递消息，RPC处理系统可能无序执行它们。所以例如如果领导者发送日志索引100的快照，然后发送日志索引110的快照，但网络先传递第二个。


问：此外，如果跟随者接收到自己日志前缀的快照，然后替换其日志到该点的条目，该点之后的条目是领导者不知道的，对吗？

答：如果网络延迟传递快照，或者领导者已发送日志条目但尚未提交它们，跟随者可能有不在接收快照中的日志条目。


问：这些条目会被提交吗？

答：它们可能被提交。


问：当步骤6的检查引用已压缩的日志条目时，InstallSnapshot RPC的处理如何处理重排序？具体来说，图13不应该包括：1.5：如果lastIncludedIndex < commitIndex，立即返回。或者1.5：如果已经有快照且lastIncludedIndex < currentSnapshot.lastIncludedIndex，立即返回。

答：我同意——对于实验3B，InstallSnapshot RPC处理器必须拒绝过时的快照。我不知道为什么图13不包括这个测试；也许作者的RPC系统在顺序方面比我们的更好。或者也许作者意图我们一般化图13中的步骤6来覆盖这种情况。


问：当领导者向我发送一个我日志前缀的InstallSnapshot命令，但我已经经历了日志压缩并且我的快照领先时，会发生什么？可以安全地假设我更靠前的快照包含了更小的快照吗？


答：是的，如果接收者已经快于该快照，接收者忽略InstallSnapshot是正确的。这种情况可能在实验3中发生，例如如果RPC系统无序传递RPC。


问：领导者如何决定哪些服务器滞后并需要发送快照安装？

答：如果跟随者由于规则#2或#3（图2中的AppendEntries RPC下）拒绝日志索引i1的AppendEntries RPC，并且领导者已经丢弃了i1之前的日志，那么领导者将发送InstallSnapshot而不是备份nextIndex[]。


问：在raft的实际使用中，快照发送频率如何？

答：我没有看到对现实生活Raft使用的分析。我想象使用Raft的人会调整它，使快照很少需要（例如通过让领导者保留大量日志条目来更新滞后的跟随者）。


问：InstallSnapshot是原子的吗？如果服务器在部分安装快照后崩溃，领导者重新发送InstallSnapshot RPC，这像RequestVote和AppendEntries RPC一样是幂等的吗？

答：InstallSnapshot的实现必须是原子的。

领导者重新发送快照是无害的。


问：为什么需要偏移量来索引InstallSNapshot RPC的data[]，是否有与快照无关的数据？或者它是否与相同快照的前一个/下一个块重叠？谢谢！

答：完整的快照可能在多个RPC中发送，每个包含完整快照的不同部分（"块"）。偏移量字段指示此RPC的数据应该在完整快照中的位置。


问：领导者如何知道何时向跟随者发送快照？

答：当跟随者的matchIndex小于领导者日志开始的索引时。


问：写时复制如何帮助创建快照的性能问题？

答：基本思想是服务器在服务想要做检查点时fork()，给子进程内存状态的完整副本。如果fork()真的复制所有内存，并且状态很大，这会很慢。但大多数操作系统不在fork()中复制所有内存；相反它们将页面标记为"写时复制"，并在父进程和子进程中都设为只读。然后如果任一尝试写入页面，操作系统将看到页面故障，操作系统只在那时复制页面。通常的净效果是子进程在fork()时看到父进程内存的副本，但相对很少复制。


问：像VIZ、ZIP、霍夫曼编码等数据压缩方案对Raft快照最有效？

答：这取决于服务存储什么数据。例如，如果它存储图像，那么你可能想用JPEG压缩它们。

如果你认为每个快照可能与之前的快照共享大量内容，那么你可能想使用某种树结构，可以在版本间共享节点。


问：向日志添加条目算作执行的操作吗？

答：不算。服务器只应在领导者指示日志条目已提交后才执行日志条目中的操作。"执行"意味着将操作交给使用Raft的服务。在实验3中，"执行"意味着Raft将提交的日志条目给你的键值软件，软件将Put(key,value)或Get(key)应用到其键值对表。


问：根据论文，当服务器认为当前领导者存在时，它们会忽略RequestVoteRPCs，但当它们认为当前领导者不存在的那一刻，我认为它们会尝试开始自己的选举。那么在什么情况下它们会实际为另一个服务器投票？

对于第二个问题，我仍然困惑：论文说当服务器认为当前领导者存在时应该忽略RequestVoteRPC是什么意思（第6节末尾）？在什么情况下服务器会认为当前领导者不存在但还没有开始自己的选举？是否如果服务器认为它还没有从服务器收到心跳但在其选举超时之前？

答：每个服务器等待随机选择的选举超时；如果它在整个期间没有收到领导者的消息，并且没有其他服务器开始选举，那么服务器开始选举。无论哪个服务器的选举计时器首先到期，都可能在任何其他服务器的计时器到期之前获得大部分或所有服务器的投票，因此可能赢得选举。

假设心跳间隔是10毫秒(ms)。领导者在时间10、20和30发送心跳。

假设服务器S1没有听到时间30的心跳。S1的选举计时器在时间35关闭，S1发送RequestVote RPC。

假设服务器S2确实听到了时间30的心跳，所以它知道服务器在那时是活着的。S2会将其选举计时器设置为不早于时间40关闭，因为只有缺少心跳才表示可能死机，并且下一个心跳直到时间40才会来。当S2在时间35听到S1的RequestVote时，S2可以忽略RequestVote，因为S2知道它听到心跳不到一个心跳间隔前。


问：我对第6讲笔记中的"如何快速回滚"部分（以及论文的相应部分）有点困惑：

  论文在第5.3节末尾概述了一个方案：
  如果跟随者拒绝，在回复中包括：
    冲突条目的任期
    冲突任期第一个条目的索引
  如果领导者知道冲突任期：
    将nextIndex[i]移动回冲突任期的最后一个条目
  否则：
    将nextIndex[i]移动回跟随者的第一个索引

我认为根据论文，领导者应该将nextIndex[i]移动到冲突任期第一个条目的索引。"如果领导者知道冲突任期"的情况是什么意思？

答：论文对算法的描述不完整，所以我们必须自己发明细节。笔记有我发明的版本；我不知道这是否是作者的想法。

论文"冲突任期第一个条目的索引"的具体问题是领导者可能根本没有冲突任期的条目。因此我的笔记涵盖两种情况——如果服务器知道冲突任期，如果不知道。


问：每次不匹配时将nextIndex减少2倍的网络/性能权衡是什么？即先减少1,2,4,8等

答：领导者会超调最多两倍，因此必须发送比需要更多的条目。当然，如果需要大量备份，图2的方法也是浪费的。最好的可能是实现更精确的东西，例如第5.3节末尾概述的优化。


问：为什么只读操作避免日志？

答：避免通过Raft运行只读操作并将它们存储在日志中更高效。只读操作通常比写操作更常见，所以这可以节省时间和空间。


问：论文说在响应只读请求之前，领导者与大部分服务器交换心跳。这如何融入现有的Raft框架？

答：领导者向所有同伴发送AppendEntry RPC（最可能是空的），并在大部分响应后回复。这比运行Raft更高效，因为操作不存储在日志中，领导者不必等待操作出现在applyCh上，这会序列化所有操作。


问：无关——你教授Raft和Paxos的经验如何对应论文的第9.1节？你的经验支持他们的发现吗？


答：我对几年前的6.824 Paxos实验很满意。我对当前的Raft实验也很满意。Raft实验更有雄心：与Paxos实验不同，Raft实验有领导者、持久性和快照。我认为我们无法阐明第9.1节的发现；我们没有对学生进行并排实验，我们的Raft实验明显更有雄心。


问：从该领域学术研究者的角度来看，Raft的影响是什么？它被认为是重要的、鼓舞人心的、非增量工作吗？还是更像是"好的，这似乎是一个自然的进展，并且更容易教授，所以我们教这个"？

答：Raft论文在解释现代复制状态机技术方面比我所知的任何论文都做得更好。我认为它激励了很多人构建自己的复制实现。


问：论文指出在野外有相当多的Raft实现。是否有任何改进建议可以合理地包含在算法的修订版中？

答：这是一个例子：

https://www.cl.cam.ac.uk/~ms705/pub/papers/2015-osr-raft.pdf