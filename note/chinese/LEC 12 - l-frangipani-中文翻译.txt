6.824 2021 第 12 讲：Frangipani

Frangipani：可扩展的分布式文件系统
Thekkath, Mann, Lee
SOSP 1997

为什么要读这篇论文？
  缓存一致性
  分布式事务
  分布式崩溃恢复
  以及三者之间的相互作用

整体设计是什么？
  网络文件系统
    与现有应用程序（文本编辑器等）透明工作
    非常像 Athena 的 AFS
  [用户；工作站 + Frangipani；网络；Petal]
  Petal：块存储服务；复制；分条+分片以提高性能
  Frangipani 在 Petal 中存储什么？
    目录、i-node、文件内容块、空闲位图
    就像普通硬盘文件系统一样
  Frangipani：去中心化文件服务；缓存以提高性能

预期用途是什么？
  环境：有协作工程师的单一实验室
    作者的研究实验室
    编程、文本处理、电子邮件等
  办公室中的工作站
  大多数文件访问是访问用户自己的文件
  需要在任何工作站之间潜在共享任何文件
    用户/用户协作
    一个用户登录到多个工作站
  所以：
    常见情况是独占访问；希望这个快速
    但文件有时需要共享；希望这个正确
  这在论文写作时是一个常见场景

为什么 Frangipani 的设计适合预期用途？
  强一致性，这是人类对文件系统的期望
  在每个工作站中缓存——写回
    所有更新最初只在工作站缓存中应用——快速
    包括例如创建文件、创建目录、重命名等
    如果所有内容都已缓存，更新无需任何 RPC 即可进行
    所以文件系统代码必须驻留在工作站中，而不是服务器中
  大部分复杂性在客户端，而不是共享的 Petal 服务器
    更多客户端 -> 更多 CPU 功率
    复杂服务器在以前的系统（如 NFS、AFS）中是严重瓶颈

Frangipani 工作站缓存中有什么？
  如果 WS1 想要创建并写入 /grades？
  从 Petal 将 / 信息读入 WS1 的缓存
  仅在缓存中添加"grades"条目
  不要立即写回 Petal！
    以防 WS1 想要进行更多修改

挑战
  WS2 运行"ls /"或"cat /grades"
    WS2 会看到 WS1 的写入吗？
    写回缓存，所以 WS 的写入不在 Petal 中
    缓存使陈旧读取成为严重威胁
    "一致性"
  WS1 和 WS2 同时尝试创建 /a 和 /b
    在同一个目录中
    它们会覆盖彼此对 / 的更改吗？
    没有中央文件服务器来解决这个问题！
    "原子性"
  WS1 在创建文件时崩溃
    许多步骤：分配 i-node、初始化 i-node、更新目录
    如果不完整会留下混乱
    如何确保其他工作站看不到混乱？如何清理？
    "崩溃恢复"

"缓存一致性"解决"读取看到写入"问题
  目标是线性化性和缓存
  许多系统使用"缓存一致性协议"
    多核、文件服务器、分布式共享内存

Frangipani 的一致性协议（简化）：
  锁服务器（LS），每个文件/目录一个锁
    文件  所有者
    -----------
    x     WS1
    y     WS1
  工作站（WS）Frangipani 缓存：
    文件/目录  锁  内容
    -----------------------
    x         忙  ...
    y         空闲  ...
  如果 WS 持有锁，
    忙：正在使用数据
    空闲：持有锁但现在不使用缓存数据
  工作站规则：
    除非持有锁，否则不缓存
    获取锁，然后从 Petal 读取
    写入 Petal，然后释放锁
  一致性协议消息：
    请求（WS -> LS）
    授权（LS -> WS）
    撤销（LS -> WS）
    释放（WS -> LS）

锁由文件/目录命名（实际上是 i-numbers），
尽管锁服务器实际上并不理解任何关于
文件系统或 Petal 的东西。

示例：WS1 更改文件 z，然后 WS2 读取 z

WS1                      LS            WS2
读取 z
  --请求(z)-->
                         所有者(z)=WS1
  <--授权(z)---
（从 Petal 读取+缓存 z 数据）
（本地修改 z）
（完成时，缓存锁在状态中）
                                       读取 z
                          <--请求(z)--
   <--撤销(z)--
（将修改的 z 写入 Petal）
   --释放(z)-->
                         所有者(z)=WS2
                           --授权(z)-->
                                       （从 Petal 读取 z）

要点：
  锁和规则强制读取看到最后写入
  锁确保"最后写入"明确定义

注意：
  在工作站释放文件锁之前，
    它必须将修改的文件内容和元数据写入 Petal
  所以工作站获得文件内容和元数据的一致性
  即文件读取看到最新内容

一致性优化
  "状态"已经是一种优化
  Frangipani 有共享读锁和独占写锁

下一个挑战：原子性
  如果两个工作站同时尝试创建同一个文件会怎样？
  部分完成的多写操作可见吗？
    例如文件创建初始化 i-node，添加目录条目
    例如重命名（两个名称都可见？都不可见？）

Frangipani 实现事务性文件系统操作：
  操作对应于系统调用（创建文件、删除文件、重命名等）
  WS 获取它将修改的所有文件系统数据的锁
  在持有所有锁的情况下执行操作
  只有在完成时才释放
    只有在整个操作完成后才响应"撤销"
  因此没有其他 WS 可以看到部分完成的操作
    并且没有其他 WS 可以同时执行冲突更新

注意 Frangipani 的锁在做两件不同的事情：
  缓存一致性（揭示写入）
  原子事务（隐藏写入）

下一个挑战：崩溃恢复

如果 Frangipani 工作站在持有锁时死亡会怎样？
  其他工作站将想要继续操作...
  我们可以直接撤销死 WS 的锁吗？
  如果死 WS 在其缓存中修改了数据怎么办？
  如果死 WS 已开始将修改的数据写回 Petal 怎么办？
    例如 WS 将新目录条目写入 Petal，但没有初始化 i-node
    这是令人担忧的情况

等待崩溃的工作站重新启动可以吗？

Frangipani 使用预写日志进行崩溃恢复
  在将操作的任何缓存块写入 Petal 之前，首先将日志写入 Petal
  所以如果崩溃的工作站已经为操作完成了一些 Petal 写入，
    但不是全部，可以从 Petal 的日志中完成写入
  非常传统——但是...
  1) Frangipani 为每个工作站有单独的日志
     这避免了日志瓶颈，便于去中心化
     但将给定文件的更新分散到多个日志中
  2) Frangipani 的日志在共享的 Petal 存储中，而不是本地磁盘
     WS2 可以读取 WS1 的日志以从 WS1 崩溃中恢复
  单独日志是一个有趣且不寻常的安排

日志中有什么？
  日志条目：
    （这有点猜测，论文不明确）
    日志序列号
    更新数组：
      块 #、新版本 #、地址、新字节
    只包含元数据更新，不包含文件内容更新
  示例——创建文件 d/f 产生日志条目：
    一个双条目更新数组：
      向 d 的内容块添加"f"条目，带有新的 i-number
      初始化 f 的 i-node
  最初日志条目在 WS 本地内存中（还不是 Petal）

当 WS 从 LS 收到修改目录的锁撤销时：
  1) 将其整个日志强制写入 Petal，然后
  2) 将缓存的更新块发送到 Petal，然后
  3) 将锁释放给 LS

为什么 WS 必须在更新
  Petal 中的 i-node 和目录等之前将日志写入 Petal？

为什么要等到 LS 撤销锁才写入日志？

当 WS1 在持有锁时崩溃会发生什么？
  不多，直到 WS2 请求 WS1 持有的锁
    LS 向 WS1 发送撤销，没有响应
    LS 超时，告诉 WS2 从 Petal 中的 WS1 日志恢复 WS1
  WS2 做什么来从 WS1 的日志恢复？
    从 Petal 读取 WS1 的日志
    执行日志操作描述的 Petal 写入
    告诉 LS 完成，所以 LS 可以释放 WS1 的锁

注意每个 WS 日志在 Petal 中是至关重要的，以便
  任何 WS 都可以读取它进行恢复。

如果 WS1 在将其最近的日志写入 Petal 之前崩溃怎么办？
  如果 WS1 崩溃，WS1 的最近操作可能完全丢失。
  但 Petal 中的文件系统将是内部一致的。

为什么尽管其他工作站对相同文件进行交错操作，
重放单个日志是安全的？
示例：
  WS1: delete(d/f)               崩溃
  WS2:               create(d/f)
  WS3:                                  恢复 WS1
  WS3 正在恢复 WS1 的日志——但它不查看 WS2 的日志
  恢复会重放删除吗？
    这是问题
    不会——被"版本号"机制阻止
    Petal 中每个元数据块（i-node）中的版本号
    每个记录操作中的版本号是块的版本加一
    仅当操作的版本 > 块版本时才重放恢复
      即只有当块还没有被此操作更新时
  WS3 需要获取 d 或 d/f 锁吗？
    不：如果版本号与操作前相同，WS1 没有
        进行写入，所以它不可能释放锁，
        所以没有其他人可以有锁，
        所以 WS3 在 Petal 中更新是安全的

日志不保存文件*内容*——后果是什么？
  工作站可能以与应用程序调用 write 不同的顺序
    将内容写入发送到 Petal。
  如果没有崩溃，这被锁隐藏，所以无关紧要。
  如果崩溃，Petal 可能留下最近写入的随机子集。
  对于许多应用程序，这无关紧要，因为崩溃不太可能
    以有用的形式留下程序输出。
  小心的程序（例如文本编辑器、数据库）使用 fsync()。
  这种行为模仿例如带有本地磁盘的 Linux。

如果：
  WS1 持有锁
  网络分区
  WS2 认为 WS1 死亡，恢复，释放 WS1 的锁
  如果 WS1 实际上活着，它随后会尝试写入锁覆盖的数据吗？
  锁有租约！
    锁所有者不能在其租约期后使用锁
    LS 在租约到期后才开始恢复

这里隐藏着 Paxos 或 Raft 吗？
  是的——用于锁服务器、Petal 服务器的基于 Paxos 的配置管理器
  确保单个锁服务器，尽管有分区
  确保每个 Petal 分片的单个主服务器

性能？
  难以判断 1997 年的数字
  它们是否达到硬件限制？磁盘带宽、网络带宽
  总吞吐量是否随着更多硬件而增加？
    每个添加的 Frangipani 工作站是否贡献更多
      容量以及更多负载？
  我们可能关心什么场景？
    读写大量小文件（例如读取我的电子邮件）
    读写巨型文件

小文件性能——图 5
  X 轴是活动工作站数量
    每个工作站运行文件密集型基准测试
    工作站使用不同的文件和目录
  Y 轴是单个工作站的完成时间
  平坦意味着良好的扩展 == 没有显著的共享瓶颈
    大概每个工作站只是使用自己的缓存
    可能 Petal 的许多磁盘也产生并行性能

大文件性能
  每个磁盘：6 MB / 秒
    Petal 分条以获得更多
  7 个 Petal 服务器，每个 Petal 服务器 9 个磁盘
    336 MB/s 原始磁盘带宽，但通过 Petal 只有 100 MB/s
  单个 Frangipani 工作站，表 3
    写入：15 MB/s——受网络链路限制
    读取：10 MB/s——受弱预取限制，可能是 15
  许多 Frangipani 工作站
    图 6——读取随着更多机器良好扩展
    图 7——写入达到 Petal 的硬件限制（复制 2 倍）

Frangipani 在什么工作负载下可能性能差？
  大量读/写共享？
  大量小文件？

Petal 细节
  Petal 为 Frangipani 提供容错存储
    所以值得讨论
  块读/写接口
    与现有文件系统兼容
  看起来像单个巨大磁盘，但许多服务器和许多磁盘
    大、高性能
    分条，64-KB 块
  虚拟：64 位稀疏地址空间，写时分配
    地址转换映射
  主/备份（一个备份服务器）
    主服务器向备份服务器发送每个写入
  使用 Paxos 同意每个虚拟地址范围的主服务器
  崩溃后恢复怎么办？
    假设对是 S1+S2
    S1 失败，S2 现在是唯一服务器
    S1 重新启动，但错过了许多更新
    S2 记住它写入的每个块的列表！
    所以 S1 只需要读取那些块，而不是整个磁盘
  日志记录
    虚拟->物理映射和错过写入信息

局限性
  最适用于例如程序员工作站，其他不太适用
    文件系统对于许多应用程序（例如网站）来说不是一个很好的 API
  Frangipani 强制执行权限，所以工作站必须受信任
    所以 Athena 不能在 Athena 工作站上运行 Frangipani
  Frangipani/Petal 分割有点尴尬
    两层都记录日志
    Petetal 可能接受来自"宕机"Frangipani 工作站的更新
    比简单文件服务器更多的 RPC 消息

要记住的想法
  复杂客户端共享简单存储——可能可扩展
  缓存一致性
  分布式事务
  分布式崩溃恢复
  上述之间的相互作用