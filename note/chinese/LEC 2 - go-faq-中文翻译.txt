Go FAQ

问：为什么6.824在实验中使用Go？

答：直到几年前，6.824使用C++，效果很好。Go在6.824实验中效果更好一些，原因有几个。Go是垃圾回收和类型安全的，这消除了一些常见的错误类别。Go对线程（goroutines）有很好的支持，还有一个很好的RPC包，这些在6.824中直接有用。线程和垃圾收集特别有效地一起工作，因为垃圾收集可以消除程序员决定使用对象的最后一个线程何时停止使用它的努力。还有其他具有这些特性的语言可能对6.824实验很适用，比如Java。

问：goroutines是并行运行的吗？你能用它们来提高性能吗？

答：Go的goroutines与其他语言中的线程相同。Go运行时在所有可用核心上并行执行goroutines。如果核心数量少于可运行的goroutines，运行时将在goroutines之间抢占式地时间共享核心。

问：Go通道是如何工作的？Go如何确保它们在许多可能的goroutines之间同步？

答：你可以看到源代码在https://golang.org/src/runtime/chan.go，虽然它不容易理解。

在高级别上，chan是一个持有缓冲区和锁的struct。在通道上发送涉及获取锁，等待（可能释放CPU）直到某个线程正在接收，然后传递消息。接收涉及获取锁并等待发送者。你可以使用Go sync.Mutex和sync.Cond实现你自己的通道。

问：我使用通道通过在通道上发送虚拟bool来唤醒另一个goroutine。但如果那个其他goroutine已经在运行（因此没有在通道上接收），发送goroutine会阻塞。我应该怎么做？

答：尝试条件变量（Go的sync.Cond）而不是通道。条件变量很好地用于提醒可能（或可能不）正在等待某事的goroutines。通道，因为它们是同步的，如果你不确定在通道的另一端是否有goroutine在等待，会变得很尴尬。

问：如何让goroutine等待来自多个不同通道中任意一个的输入？如果在任何通道上尝试接收时没有东西可读，会阻塞goroutine，阻止它检查其他通道。

答：尝试为每个通道创建一个单独的goroutine，并让每个goroutine在其通道上阻塞。这并不总是可能，但当它工作时通常是最简单的方法。

否则尝试Go的select。

问：什么时候我们应该使用sync.WaitGroup而不是通道？反之亦然？

答：WaitGroup是相当特殊用途的；只在等待一堆活动完成时有用。通道更通用；例如，你可以通过通道通信值。你可以使用通道等待多个goroutines，虽然它比使用WaitGroup需要更多的代码行。

问：我需要我的代码每秒执行一次任务。最简单的方法是什么？

答：创建一个专门用于该周期任务的goroutine。它应该有一个使用time.Sleep()暂停一秒钟的循环，然后执行任务，然后循环回到time.Sleep()。

问：我们如何知道生成goroutines的开销超过我们从中获得的并发性？

答：这取决于！如果你的机器有16个核心，你正在寻找CPU并行性，你应该有大约16个可执行的goroutines。如果获取网页需要0.1秒的实时时间，并且你的网络能够每秒传输100个网页，你可能需要大约10个goroutines并发获取以使用所有网络容量。实验上，随着你增加goroutines的数量，一段时间你会看到增加的吞吐量，然后你将停止获得更多吞吐量；在那个时候，从性能的角度看你有足够的goroutines。

问：如何创建一个通过互联网连接的Go通道？如何指定用于发送消息的协议？

答：Go通道只在单个程序内工作；通道不能用于与其他程序或其他计算机通信。

看看Go的RPC包，它让你通过互联网与其他Go程序通信：

  https://golang.org/pkg/net/rpc/

问：有哪些重要/有用的Go特定并发模式需要知道？

答：这是一个关于这个主题的幻灯片，来自Go专家：

https://talks.golang.org/2012/concurrency.slide

问：切片是如何实现的？

答：切片是一个包含指向数组的指针以及该数组的开始和结束索引的对象。这种安排允许多个切片共享底层数组，每个切片可能暴露不同的数组元素范围。

这是一个更扩展的讨论：

  https://blog.golang.org/go-slices-usage-and-internals

我经常使用切片，从不使用数组。Go切片比Go数组更灵活，因为数组的大小是其类型的一部分，而接受切片作为参数的函数可以接受任何长度的切片。

问：人们使用Go的常见调试工具有哪些？

答：fmt.Printf()

据我所知，Go没有一个很好的调试器，虽然gdb可以工作：

https://golang.org/doc/gdb

无论如何，对于大多数错误，我发现fmt.Printf()是一个极其有效的调试工具。

问：什么时候使用同步RPC调用是正确的，什么时候使用异步RPC调用是正确的？

答：大多数代码在继续之前需要RPC回复；在这种情况下使用同步RPC是有意义的。

但有时客户端想要启动许多并发RPC；在这种情况下异步可能更好。或者客户端想要在等待RPC完成时做其他工作，也许因为服务器很远（所以光速时间很高）或者因为服务器可能不可达所以RPC遭受长时间超时。

我从未在Go中使用异步RPC。当我想发送RPC但不必等待结果时，我创建一个goroutine，并让goroutine进行同步Call()。

问：Go在工业中使用吗？

答：你可以在这里看到不同编程语言使用程度的估计：

https://www.tiobe.com/tiobe-index/

问：开发者在开始使用Go时面临的常见问题是什么？

答：我没有做科学研究，但我想象这些在列表上：

- 当有并发访问时不用锁保护map。（但使用竞争检测器来捕获这些）。

- 通道死锁。

- 创建goroutine时不捕获变量。

- 泄漏goroutines

问：Go支持继承吗？（在Java/C++的"extends"方式？）

答：Go不支持C++风格的继承，但有接口和嵌入式结构，这允许你做许多在C++中使用继承的事情。这是Go设计中备受争议的部分；谷歌搜索"golang generics"。

问：我在Go教程中发现最令人困惑的是goroutines在主线程完成后不继续执行。我不认为教程中明确提到了这一点；我是通过调试爬虫练习弄清楚的。

答：是的，我不认为它在教程中，但语言规范对此很明确：https://golang.org/ref/spec（参见程序执行）。

问：我对何时选择值或指针接收者仍然有些困惑。你能提供一些具体的/真实世界的例子说明我们何时会选择一个而不是另一个吗？

答：当你想修改接收者的状态时，你必须使用指针接收者。如果结构体非常大，你可能想使用指针接收者，因为值接收者在副本上操作。如果两者都不适用，你可以使用值接收者。但是，要小心值接收者；例如，如果你在结构体中有互斥锁，你不能让它成为值接收者，因为互斥锁会被复制，违背了它的目的。