6.824 2021 第15讲：FaRM，乐观并发控制

为什么要学习FaRM？
  这是关于事务+复制+分片的另一种实现方式
    这仍然是一个活跃的研究领域！
  其动机来自于RDMA网卡巨大的性能潜力

FaRM与Spanner有何不同？
  两者都使用复制和两阶段提交（2pc）来处理事务
  Spanner：
    一个已部署的系统
    专注于地理复制
      例如在东西海岸都有副本，以防数据中心故障
    最具创新性的是只读事务——TrueTime
    性能：读写事务需要10到100毫秒（表3和表6）
  FaRM
    一个研究原型，用于探索RDMA的潜力
    所有副本都在同一个数据中心（否则没有意义）
    RDMA限制了设计选择：因此采用乐观并发控制（OCC）
    性能：简单事务需要58微秒（6.3节，图7）
      即比Spanner快100倍
    性能：在90台机器上达到每秒1亿次的吞吐量（图7）
      对于事务+复制来说，这是极其令人印象深刻的
  它们针对不同的瓶颈：
    Spanner：光速和网络延迟
    FaRM：服务器上的CPU时间

整体架构
  都在一个数据中心内
  配置管理器使用ZooKeeper选择主副本和备份副本
  分片并使用主副本/备份副本复制
    P1 B1
    P2 B2
    ...
    只要每个分片至少有一个副本就能恢复
    即f+1个副本可以容忍f个故障
  事务客户端（它们在服务器中运行）
  事务代码作为两阶段提交的事务协调器（TC）

它们如何获得高性能？
  在多个服务器上分片（评估中使用了90台服务器）
  数据必须能放入总内存中（因此不需要磁盘读取）
  非易失性内存（因此不需要磁盘写入）
  单边RDMA（对内存的快速跨网络访问）
  快速的用户级网卡访问
  利用单边RDMA的事务+复制协议

NVRAM（非易失性内存）
  FaRM写入内存而不是磁盘——消除了一个巨大的瓶颈
  内存写入需要200纳秒，硬盘写入需要10毫秒，SSD写入需要100微秒
    ns = 纳秒，ms = 毫秒，us = 微秒
  但内存在断电时会丢失内容！本身不是持久化的。
  为什么不直接写入f+1台机器的内存来容忍f个故障？
    如果故障总是独立的，这可能就足够了
    但断电不是独立的——可能影响100%的机器！
  所以：
    每个机架都有电池，可以让机器运行几分钟
    硬件在主电源故障时通知软件
    软件停止所有事务处理
    软件将FaRM的内存写入SSD；可能需要几分钟
    然后机器关闭
    重启时，FaRM从SSD读取保存的内存映像
    "非易失性内存"
  如果崩溃导致软件无法写入SSD怎么办？
    例如FaRM或内核的bug，或者cpu/内存/硬件错误
    FaRM通过从机器副本的内存复制数据到其他机器来处理单机崩溃
      以确保始终有f+1个副本
    崩溃（除了断电）必须是独立的！
  总结：
    NVRAM消除了持久化写入瓶颈
    剩下的瓶颈是网络和CPU

为什么网络经常是性能瓶颈？
  通过TCP在LAN上进行RPC的通常设置：
    app                       app
    ---                       ---
    socket buffers            buffers
    TCP                       TCP
    NIC driver                driver
    NIC  -------------------- NIC
  许多昂贵的CPU操作：
    系统调用
    复制消息
    中断
  缓慢：
    难以构建每秒超过几十万次的RPC
    线路带宽（例如10千兆比特/秒）很少是短RPC的限制
    每包CPU成本是小消息的限制因素

FaRM使用两个网络概念：
  内核旁路
  RDMA

内核旁路
  [图表：FaRM用户程序，CPU核心，DMA队列，网卡]
  应用程序直接与网卡交互——没有系统调用，没有内核
  网卡直接与用户内存进行DMA传输
  FaRM软件轮询DMA区域以检查新消息

RDMA（远程直接内存访问）
  [源主机，网卡，交换机，网卡，目标内存，目标CPU]
  远程网卡直接读取/写入内存
    发送方提供内存地址
    远程CPU不参与！
    这就是"单边RDMA"
    原子地读取整个缓存行
    （写入方面不确定）
  RDMA网卡使用可靠协议，带有ACK
  一台服务器的吞吐量：每秒1000万+次（图2）
  延迟：5微秒（来自他们2014年NSDI论文）

如果客户端能通过RDMA直接访问服务器上的DB记录，性能将是惊人的！

问：事务能否直接通过单边RDMA进行读/写？

如何将RDMA与复制和事务结合？
  到目前为止我们看到的协议都需要服务器的主动参与。
  例如：该记录是否被锁定？
       哪个是最新版本？
       该写入是否已提交？
  与单边RDMA不立即兼容。

事务的并发控制分为两类：
  悲观：
    在首次使用对象时等待锁；持有直到提交/中止
    称为两阶段锁定
    冲突导致延迟
  乐观：
    无锁读取对象
    直到提交时才安装写入
    提交时"验证"以查看是否有其他事务冲突
    有效：提交写入
    无效：中止
    称为乐观并发控制（OCC）

FaRM使用OCC
  原因：
    OCC让FaRM使用单边RDMA读取
    服务器不需要主动参与（由于OCC，不需要锁）
  FaRM如何验证？我们稍后看一下图4。

FaRM事务API（简化版）：
  txCreate()
  o = txRead(oid)  -- RDMA
  o.f += 1
  txWrite(oid, o)  -- 纯本地操作
  ok = txCommit()  -- 图4

什么是oid？
  <区域号，地址>
  区域号索引到[主副本，备份1，...]的映射
  目标RDMA网卡直接使用地址来读/写内存

服务器内存布局
  区域，每个区域是一个对象数组
  对象布局
    包含版本号的头部，以及版本号高位的锁标志位
  对于每台其他服务器
    （由RDMA写入，通过轮询读取）
    传入日志
    传入消息队列
  所有这些都在非易失性内存中（即断电时写入SSD）

图4：事务执行/提交协议
  让我们逐一考虑图4中的步骤
  专注于并发控制（而不是容错）

执行阶段
  TC（客户端）从服务器读取它需要的对象
    包括它将要写入的记录
    使用单边RDMA读取
    不加锁
    这就是乐观并发控制中的"乐观"
  TC记住版本号
  TC缓冲写入

LOCK（提交协议中的第一条消息）
  TC发送给每个写入对象的主副本
  TC使用RDMA追加到每个主副本的日志
  LOCK记录包含oid、事务读取的版本号、新值
  LOCK现在记录在主副本的NVRAM中，以防断电

主副本收到LOCK时做什么？
  它轮询内存中的传入日志，看到我们的LOCK
  如果对象被锁定，或版本号 != 事务读取的版本号，回复"no"
  否则设置锁标志位并返回"yes"
  锁检查、版本检查和锁设置是原子的
    使用原子比较交换指令
    "locked"标志是版本号的高位
    以防其他CPU也在处理LOCK，或者客户端正在用RDMA读取
  如果对象已经被锁定，不会阻塞，只是回复"no"
    这将导致TC中止事务

TC等待所有LOCK回复消息
  如果有任何"no"，就中止
    向主副本日志追加ABORT以便它们可以释放锁
    从txCommit()返回"no"

现在让我们暂时忽略VALIDATE和COMMIT BACKUP

此时主副本需要知道TC的决定

TC向主副本日志追加COMMIT-PRIMARY
  TC只等待RDMA硬件确认（ack）
    不等待主副本处理日志条目
    硬件ack意味着在主副本的NVRAM中是安全的
  TC从txCommit()返回"yes"

当主副本处理其日志中的COMMIT-PRIMARY时：
  将新值复制到对象内存上
  增加对象的版本号
  清除对象的锁标志位

示例：
  T1和T2都想增加x
    x = x + 1
  串行性允许什么结果？
    即如果一次运行一个，可能的结果是什么？
    x = 2，两个客户端都被告知"成功"
    x = 1，一个客户端被告知"成功"，另一个"中止"
    x = 0，两个客户端都被告知"中止"

如果T1和T2完全同步会怎样？
  T1: Rx0  Lx  Cx
  T2: Rx0  Lx  Cx
  会发生什么？

或者
  T1:    Rx0 Lx Cx
  T2: Rx0          Lx  Cx

或者
  T1: Rx0  Lx  Cx
  T2:             Rx0  Lx  Cx

为什么FaRM的OCC提供串行性的直观理解：
  即检查"执行是否与一次运行一个相同？"
  如果没有冲突的事务：
    版本号不会改变
  如果有冲突的事务：
    其中一个会看到锁或改变的版本号

图4中的VALIDATE是什么？
  它是对事务只读取对象的一种优化
  VALIDATE = 单边RDMA读取，重新获取对象的版本号和锁标志位
  如果设置了锁，或版本号自读取后已改变，TC中止
  不设置锁，因此比LOCK+COMMIT更快

VALIDATE示例：
x和y初始为零
T1:
  if x == 0:
    y = 1
T2:
  if y == 0:
    x = 1
（这是强一致性的经典测试示例）
T1,T2结果为y=1,x=0
T2,T1结果为x=1,y=0
中止可能留下x=0,y=0
但串行性禁止x=1,y=1

假设同时发生：
  T1:  Rx  Ly  Vx  Cy
  T2:  Ry  Lx  Vy  Cx
  会发生什么？
  LOCK都会成功！
  VALIDATE都会失败，因为锁位都被设置了
  所以两个都会中止——这是可以的

这样如何：
  T1:  Rx  Ly  Vx      Cy
  T2:  Ry          Lx  Vy  Cx
  T1提交
  T2中止，因为T2的Vy看到T1的锁或更高的版本号
但我们不能让两个V都在另一个L之前
所以在这个例子中VALIDATE似乎是正确的
  而且很快：单边VALIDATE读取而不是LOCK+COMMIT写入

纯只读的FaRM事务只使用单边RDMA读取
  没有写入，没有日志记录
  非常快！

容错方面呢？
  一些计算机崩溃且不重启
  如果TC和一些主副本崩溃，最有趣
  但我们假设每个分片的一个备份副本能幸存

关键问题：
  如果一个事务被故障中断，
    客户端可能被告知事务已提交，
    或者提交的值可能被其他事务读取，
  那么该事务必须在恢复期间被保留和完成。

看图4。
一个已提交的写入可能在第一个COMMIT-PRIMARY发送时就暴露
  （因为主副本写入并解锁）。
所以到那时，事务的所有写入必须在所有相关分片的
  所有f+1个副本上。
好消息：LOCK和COMMIT-BACKUP实现了这一点。
  LOCK告诉所有主副本新值。
  COMMIT-BACKUP告诉所有备份副本新值。
  TC直到所有LOCK和COMMIT-BACKUP完成才发送COMMIT-PRIMARY。
  备份副本可能还没有处理COMMIT-BACKUPs，但在NVRAM日志中。

类似地，TC直到至少一个COMMIT-PRIMARY在主副本日志中安全后才返回客户端。
  没有COMMIT-PRIMARY，风险情况是：
    TC返回客户端后，一个分片的所有带COMMIT-BACKUP的备份都失败了
    现在没有证据来断定事务已提交
      事务唯一的证据是LOCK记录，
      它在验证之前写入，所以我们不知道事务是否提交/中止
  写入COMMIT-PRIMARY处理了风险，因为TC的
     决定将在任何分片的f个故障中幸存。
  因为有一个分片有完整的COMMIT-BACKUP和COMMIT-PRIMARY集合。
  其中任何一个都是主副本决定提交的证据。

FaRM非常令人印象深刻；它有什么不足吗？
  * 由于OCC，在冲突少的情况下效果最好。
  * 数据必须能放入总内存中。
  * 复制只在数据中心内（没有地理分布）。
  * 数据模型是低级的；需要例如SQL库。
  * 细节由特定的网卡特性驱动；如果网卡有测试和设置功能怎么办？
  * 需要一些不寻常的RDMA和NVRAM硬件。

总结
  超高速分布式事务
  硬件是奇特的（NVRAM和RDMA）但可能很快就会普及
  使用OCC来提高速度并允许快速的单边RDMA读取