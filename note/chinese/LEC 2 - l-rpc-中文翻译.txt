6.824 2021 第2讲：基础设施：RPC和线程

今天的内容：
  Go中的线程和RPC，为实验做准备

为什么选择Go？
  良好的线程支持
  便捷的RPC
  类型安全
  垃圾回收（没有释放后使用的问题）
  线程+垃圾回收特别有吸引力！
  相对简单
  教程完成后，使用 https://golang.org/doc/effective_go.html

线程
  一个有用的结构化工具，但可能比较复杂
  Go称之为goroutines；其他人都称之为threads

线程 = "执行线程"
  线程允许一个程序同时做多件事情
  每个线程按顺序执行，就像普通的非线程程序一样
  线程共享内存
  每个线程包含一些每线程状态：
    程序计数器、寄存器、栈

为什么需要线程？
  它们表达并发性，这在分布式系统中是必需的
  I/O并发
    客户端并行向多个服务器发送请求并等待回复。
    服务器处理多个客户端请求；每个请求可能会阻塞。
    在等待磁盘为客户端X读取数据时，
      处理来自客户端Y的请求。
  多核性能
    在多个核心上并行执行代码。
  便利性
    在后台，每秒检查一次每个工作进程是否仍然存活。

有线程的替代方案吗？
  有的：编写在单个线程中显式交错活动的代码。
    通常称为"事件驱动"。
  维护每个活动的状态表，例如每个客户端请求。
  一个"事件"循环：
    检查每个活动的新输入（例如服务器回复的到达），
    为每个活动执行下一步，
    更新状态。
  事件驱动提供I/O并发，
    并消除线程成本（可能相当可观），
    但不能获得多核加速，
    并且编程很痛苦。

线程挑战：
  共享数据
    例如，如果两个线程同时执行 n = n + 1 会怎样？
      或者一个线程在读取而另一个线程在递增？
    这是一个"竞争"——通常是一个bug
    -> 使用锁（Go的sync.Mutex）
    -> 或者避免共享可变数据
  线程间协调
    例如，一个线程正在生产数据，另一个线程正在消费数据
      消费者如何等待（并释放CPU）？
      生产者如何唤醒消费者？
    -> 使用Go通道或sync.Cond或WaitGroup
  死锁
    通过锁和/或通信（例如RPC或Go通道）的循环

让我们看看教程中的网络爬虫作为线程示例。

什么是网络爬虫？
  目标是获取所有网页，例如提供给索引器
  网页和链接形成一个图
  多个链接指向某些页面
  图有循环

爬虫挑战
  利用I/O并发
    网络延迟比网络容量更限制性能
    同时获取多个URL
      以增加每秒获取的URL数量
    => 需要线程来实现并发
  每个URL只获取一次
    避免浪费网络带宽
    对远程服务器友好
    => 需要记住哪些URL已访问
  知道何时完成

我们将看两种解决方案风格[见课程安排页面的crawler.go]

串行爬虫：
  通过递归Serial调用执行深度优先探索
  "fetched"映射避免重复，打破循环
    一个单一的映射，通过引用传递，调用者可以看到被调用者的更新
  但是：一次只获取一个页面
    我们可以在Serial()调用前加一个"go"吗？
    让我们试试看...发生了什么？

并发互斥锁爬虫：
  为每个页面获取创建一个线程
    多个并发获取，更高的获取速率
  "go func"创建一个goroutine并开始运行
    func...是"匿名函数"
  线程共享"fetched"映射
    所以只有一个线程会获取任何给定的页面
  为什么需要互斥锁（Lock()和Unlock()）？
    一个原因：
      两个不同的网页包含指向相同URL的链接
      两个线程同时获取这两个页面
      T1读取fetched[url]，T2读取fetched[url]
      两者都看到url尚未被获取（already == false）
      两者都获取，这是错误的
      锁使检查和更新成为原子操作
        所以只有一个线程看到already==false
    另一个原因：
      内部，映射是一个复杂的数据结构（树？可扩展哈希？）
      并发更新/更新可能破坏内部不变量
      并发更新/读取可能使读取崩溃
    如果我注释掉Lock() / Unlock()会怎样？
      go run crawler.go
        为什么它能工作？
      go run -race crawler.go
        即使输出正确也能检测到竞争！
  ConcurrentMutex爬虫如何决定它完成了？
    sync.WaitGroup
    Wait()等待所有Add()被Done()平衡
      即等待所有子线程完成
    [图：goroutine树，覆盖在循环URL图上]
    树中每个节点有一个WaitGroup
  这个爬虫可能创建多少并发线程？

并发通道爬虫
  Go通道：
    通道是一个对象
      ch := make(chan int)
    通道允许一个线程向另一个线程发送对象
    ch <- x
      发送者等待直到某个goroutine接收
    y := <- ch
      for y := range ch
      接收者等待直到某个goroutine发送
    通道既通信又同步
    多个线程可以在同一个通道上发送和接收
    通道很便宜
    记住：发送者阻塞直到接收者接收！
      "同步"
      注意死锁
  ConcurrentChannel master()
    master()创建一个worker goroutine来获取每个页面
    worker()在通道上发送页面的URL切片
      多个worker在单个通道上发送
    master()从通道读取URL切片
  master在哪一行等待？
    master在等待时使用CPU时间吗？
  不需要锁定fetched映射，因为它不被共享！
  master如何知道它完成了？
    在n中保持worker的计数。
    每个worker在通道上只发送一个项目。

为什么多个线程使用同一个通道不是竞争？

当worker线程写入URL切片，而master线程读取该切片时，是否存在竞争？
  * worker只在发送前写入切片
  * master只在接收后读取切片
  所以它们不能同时使用切片。

何时使用共享和锁， versus 通道？
  大多数问题可以用任一风格解决
    什么最有意义取决于程序员的思维方式
    状态——共享和锁
    通信——通道
  对于6.824实验，我推荐状态使用共享+锁，
    等待/通知使用sync.Cond或通道或time.Sleep()。

远程过程调用（RPC）
  分布式系统机器的关键部分；所有实验都使用RPC
  目标：易于编程的客户端/服务器通信
  隐藏网络协议的细节
  将数据（字符串、数组、映射等）转换为"线格式"

RPC消息图：
  客户端             服务器
    请求--->
       <---响应

软件结构
  客户端应用        处理函数
   存根函数         调度器
   RPC库           RPC库
     网络  ------------ 网络

Go示例：见课程安排页面的kv.go
  一个玩具键/值存储服务器——Put(key,value), Get(key)->value
  使用Go的RPC库
  通用部分：
    为每个服务器处理程序声明Args和Reply结构。
  客户端：
    connect()的Dial()创建到服务器的TCP连接
    get()和put()是客户端"存根"
    Call()要求RPC库执行调用
      你指定服务器函数名、参数、放置回复的位置
      库序列化参数，发送请求，等待，反序列化回复
      Call()的返回值指示是否收到回复
      通常你也有reply.Err表示服务级故障
  服务器：
    Go要求服务器声明一个带有方法的对象作为RPC处理程序
    然后服务器向RPC库注册该对象
    服务器接受TCP连接，将它们交给RPC库
    RPC库
      读取每个请求
      为此请求创建新的goroutine
      反序列化请求
      查找命名对象（在Register()创建的表中）
      调用对象的命名方法（调度）
      序列化回复
      在TCP连接上写入回复
    服务器的Get()和Put()处理程序
      必须锁定，因为RPC库为每个请求创建新的goroutine
      读取参数；修改回复

一些细节：
  绑定：客户端如何知道与哪个服务器计算机通信？
    对于Go的RPC，服务器名称/端口是Dial的参数
    大型系统有某种名称或配置服务器
  序列化：将数据格式化为数据包
    Go的RPC库可以传递字符串、数组、对象、映射等
    Go通过复制指向的数据来传递指针
    不能传递通道或函数

RPC问题：如何处理故障？
  例如，数据包丢失、网络中断、服务器缓慢、服务器崩溃

故障对客户端RPC库来说是什么样的？
  客户端永远看不到服务器的响应
  客户端不知道服务器是否看到了请求！
    [各点丢失的图]
    也许服务器从未看到请求
    也许服务器执行了，在发送回复前崩溃了
    也许服务器执行了，但网络在传递回复前就死了

最简单的故障处理方案："尽力而为"
  Call()等待响应一段时间
  如果没有到达，重新发送请求
  这样做几次
  然后放弃并返回错误

问："尽力而为"对应用程序来说容易处理吗？

一个特别糟糕的情况：
  客户端执行
    Put("k", 10);
    Put("k", 20);
  两者都成功
  Get("k")会产生什么？
  [图，超时，重新发送，原始请求晚到]

问：尽力有为何时可以？
   只读操作
   重复时不做任何操作的操作
     例如，DB检查记录是否已经插入

更好的RPC行为："最多一次"
  想法：服务器RPC代码检测重复请求
    返回先前的回复而不是重新运行处理程序
  问：如何检测重复请求？
  客户端为每个请求包含唯一ID（XID）
    重新发送使用相同的XID
  服务器：
    if seen[xid]:
      r = old[xid]
    else
      r = handler()
      old[xid] = r
      seen[xid] = true

一些最多一次的复杂性
  这将在实验3中出现
  如果两个客户端使用相同的XID怎么办？
    大随机数？
    将唯一客户端ID（IP地址？）与序列号组合？
  服务器必须最终丢弃关于旧RPC的信息
    什么时候丢弃安全？
    想法：
      每个客户端有唯一ID（也许是大随机数）
      每客户端RPC序列号
      客户端在每个RPC中包含"看到所有回复<= X"
      很像TCP序列号和确认
    或者只允许客户端一次有一个未完成的RPC
      seq+1的到达允许服务器丢弃所有<= seq
  如何在原始请求仍在执行时处理重复请求？
    服务器还不知道回复
    想法：每个执行的RPC有"pending"标志；等待或忽略

如果最多一次服务器崩溃并重启怎么办？
  如果最多一次的重复信息在内存中，服务器会忘记
    并在重启后接受重复请求
  也许它应该将重复信息写入磁盘
  也许副本服务器也应该复制重复信息

Go RPC是"最多一次"的简单形式
  打开TCP连接
  将请求写入TCP连接
  Go RPC从不重新发送请求
    所以服务器不会看到重复请求
  Go RPC代码如果没有收到回复就返回错误
    也许在超时后（来自TCP）
    也许服务器没有看到请求
    也许服务器处理了请求但服务器/网络在回复回来前失败了

"恰好一次"呢？
  无限重试加重复检测加容错服务
  实验3