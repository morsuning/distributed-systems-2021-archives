6.824 2021 第8讲：ZooKeeper案例研究

阅读："ZooKeeper: wait-free coordination for internet-scale systems", Patrick
Hunt, Mahadev Konar, Flavio P. Junqueira, Benjamin Reed。2010年USENIX年度技术会议论文集。

这篇论文阐明了什么问题？
  * 我们能将协调作为独立的通用服务吗？
    API应该是什么样的？
    其他分布式应用程序如何使用它？
  * 我们为Nx台复制服务器花了很多钱。
    我们能从它们获得Nx性能吗？

首先，性能。
  现在，将ZooKeeper视为使用类似Raft方案复制的服务。
  很像实验3。
  [客户端，领导者/状态/日志，跟随者/状态/日志]

当我们添加更多服务器时，这种复制安排会变得更快吗？
  假设一个繁忙的系统，大量活跃客户端。
  随着副本增多，写入可能会变慢！
    因为领导者必须将每个写入发送给越来越多的跟随者。
  读取呢？

问：副本可以从其本地状态提供只读客户端请求吗？
   不涉及领导者或其他副本？
   那么总读取容量将是O(#服务器)，而不是O(1)！

问：从跟随者的读取是线性化的吗？
   读取总是产生新鲜数据吗？
   不：
     副本可能不在多数中，所以可能没有看到完成的写入。
     副本可能还没有看到完成写入的提交。
     副本可能完全与领导者断开（同上）。
   线性化禁止陈旧读取！

问：如果客户端从一个最新的副本读取，然后从一个滞后的副本读取呢？
   它可能看到数据值在时间上倒退！也被禁止。

Raft和实验3避免了这些问题。
  客户端必须将读取发送给领导者。
  所以实验3读取是线性化的。
  但没有机会将读取负载分散到跟随者上。

ZooKeeper如何解决这个问题？
  通过改变正确性的定义！
  它允许读取产生陈旧数据。
  但在其他方面保留顺序。

顺序保证（第2.3节）
  * 线性化写入
    客户端将写入发送给领导者
    领导者选择一个顺序，用"zxid"编号
    发送给副本，所有副本都按zxid顺序执行
    这就像实验一样
  * FIFO客户端顺序
    每个客户端为其操作指定顺序（读取和写入）
    写入：
      写入以客户端指定的顺序出现在写入顺序中
      这是2.3节中关于"ready"文件的事情
    读取：
      每个读取在写入顺序中的特定点执行
      客户端的连续读取在顺序中的非递减点执行
      客户端的读取在该客户端所有先前写入之后执行
        服务器可能阻塞客户端的读取以等待先前的写入，或sync()

为什么这是合理的？
  即为什么读取返回陈旧数据是可以的？
       为什么客户端1看到新数据，然后客户端2看到较旧数据是可以的？

在高级别上：
  对程序员来说不像看起来那么痛苦
  对读取性能非常有帮助！

尽管一致性宽松，为什么ZooKeeper仍然有用？
  sync()使后续客户端读取看到前面的写入。
    当读取必须看到最新数据时很有用
  写入行为良好，例如排他性测试和设置操作
    写入确实按顺序执行，在最新数据上。
  读取顺序规则确保"读取自己的写入"。
  读取顺序规则有助于推理。
    例如，如果读取看到"ready"文件，后续读取看到先前的写入。
         （第2.3节）
         写入顺序：      读取顺序：
         delete("ready")
         write f1
         write f2
         create("ready")
                           exists("ready")
                           read f1
                           read f2
         即使客户端切换服务器！
    例如，由写入触发的监视器在来自后续写入的读取之前传递。
         写入顺序：      读取顺序：
                           exists("ready", watch=true)
                           read f1
         delete("ready")
         write f1
         write f2
                           read f2

一些结果：
  领导者必须在领导者故障时保持客户端写入顺序。
  副本必须强制执行"客户端的读取在zxid顺序中永不倒退"
    尽管有副本故障。
  客户端必须跟踪它已读取的最高zxid
    以帮助确保下次读取不倒退
    即使发送到不同的副本

ZooKeeper中的其他性能技巧：
  客户端可以向领导者发送异步写入（async = 不必等待）。
  领导者批处理许多请求以减少网络和磁盘写入开销。
    假设有大量活跃客户端。
  模糊快照（和幂等更新）使快照不会停止写入。

产生的性能好吗？
  表1
  高读取吞吐量——并且随着服务器数量增加而上升！
  较低的写入吞吐量——并且随着服务器数量增加而下降！
  每秒21,000次写入相当好！
    也许受限于将日志持久化到硬盘的时间。
    但仍然远高于每次磁盘写入10毫秒——批处理。

另一个ZooKeeper大主题：通用协调服务。
  这是关于API以及它如何帮助分布式软件协调。
  不清楚这样的API应该是什么样的！

我们所说的作为服务的协调是什么意思？
  示例：VMware-FT的测试和设置服务器
    如果一个副本不能与另一个通信，获取t-a-s锁，成为唯一服务器
    必须是排他性的以避免两个主控（例如如果网络分区）
    必须容错
  示例：GFS（更推测）
    也许关于哪个元数据副本应该是主控的协议
    也许记录块服务器列表，哪些块，谁是主要的
  其他示例：MapReduce、YMB、Crawler等
    谁是主控；工作者列表；劳动分工；任务状态
  通用服务将节省大量精力！

我们能使用实验3键值存储作为通用协调服务吗？
  例如，如果多个副本想要接管，选择新的GFS主控？
  也许
    Put("master", my IP address)
    if Get("master") == my IP address:
      作为主控行动
  问题：竞争的Put()可能在Get()之后执行
    第2个Put()覆盖第1个，所以两个主控，糟糕
    Put()和Get()不是互斥的好API！
  问题：如果主控失败怎么办？
    也许主控重复Put()一个新鲜时间戳？
    大量轮询...
  问题：客户端需要知道主控何时改变
    周期性Get()？
    大量轮询...

Zookeeper API概述（图1）
  状态：类似文件系统的znode树
  文件名、文件内容、目录、路径名
  典型用法：znode中的配置信息
    参与应用程序的机器集合
    哪台机器是主控
  每个znode有版本号
  znode类型：
    常规
    临时
    顺序：名称 + 序号

对znode的操作（第2.2节）
  create(path, data, flags)
    排他性——只有第一个创建表示成功
  delete(path, version)
    如果znode.version = version，则删除
  exists(path, watch)
    watch=true意味着如果路径后来被创建/删除也发送通知
  getData(path, watch)
  setData(path, data, version)
    如果znode.version = version，则更新
  getChildren(path, watch)
  sync()
    sync然后读取确保sync之前的写入对同一客户端的读取可见
    客户端可以改为提交写入

ZooKeeper API为同步调整得很好：
  + 排他性文件创建；只有一个并发创建返回成功
  + getData()/setData(x, version)支持迷你事务
  + 会话在客户端失败时自动执行操作（例如失败时释放锁）
  + 顺序文件在多个客户端之间创建顺序
  + 监视器——避免轮询

示例：向存储在ZooKeeper znode中的数字加一
  如果读取返回陈旧数据怎么办？
    写入将写入错误的值！
  如果另一个客户端并发更新怎么办？
    其中一个增量会丢失吗？
  while true:
    x, v := getData("f")
    if setData(x + 1, version=v):
      break
  这是一个"迷你事务"
    效果是原子读取-修改-写入
  许多变体，例如VMware-FT的测试和设置

示例：简单锁（第2.4节）
  acquire():
    while true:
      if create("lf", ephemeral=true), success
      if exists("lf", watch=true)
        等待通知

  release(): (自愿或会话超时)
    delete("lf")

  问：如果锁在失败者调用exists()时刚好被释放怎么办？

示例：无群效应的锁
  （查看论文中的伪代码，第2.4节，第6页）
  1. 创建一个"顺序"文件
  2. 列出文件
  3. 如果没有较低编号的，锁被获取！
  4. if exists(next-lower-numbered, watch=true)
  5.   等待事件...
  6. 转到2

  问：较低编号的文件可能在步骤2和3之间创建吗？
  问：监视器可以在轮到客户端之前触发吗？
  答：是的
     lock-10 <- 当前锁持有者
     lock-11 <- 下一个
     lock-12 <- 我的请求

     如果创建lock-11的客户端在获得锁之前死亡，
     监视器将触发但还没轮到我。

使用这些锁
  与单机线程锁不同！
    如果锁持有者失败，系统自动释放锁。
    所以锁并不真正强制其他活动的原子性。
    要使写入原子化，使用"ready"技巧或迷你事务。
  用于主控/领导者选举。
    新领导者必须检查状态并清理。
  或软锁，用于性能但不是为了正确性
    例如只有一个工作者做每个Map或Reduce任务（但做两次也可以）
    例如URL只被一个工作者爬取（但做两次也可以）

ZooKeeper是成功的设计。
  参见ZooKeeper的维基百科页面以获取使用它的项目列表
  很少消除分布式的所有复杂性。
    例如GFS主控仍然需要复制文件元数据。
    例如GFS主要有自己的复制块计划。
  但确实解决了一堆常见情况：
    主控选举。
    持久主控状态（如果状态小）。
    谁是当前主控？（名称服务）。
    工作者注册。
    工作队列。

未涵盖的主题：
  持久性
  批处理和流水线性能细节
  模糊快照
  幂等操作
  重复客户端请求检测

参考文献：
  https://zookeeper.apache.org/doc/r3.4.8/api/org/apache/zookeeper/ZooKeeper.html
  ZAB: http://dl.acm.org/citation.cfm?id=2056409
  https://zookeeper.apache.org/
  https://cs.brown.edu/~mph/Herlihy91/p124-herlihy.pdf  (wait free, universal
  objects, etc.)