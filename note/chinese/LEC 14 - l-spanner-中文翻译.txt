6.824 2021 第14讲：Spanner

为什么这篇论文（Google Spanner，OSDI 2012）？
  广域分布式事务的罕见例子。
    非常可取。
    但两阶段提交被认为太慢且容易阻塞。
  广域同步复制的罕见例子。
  巧妙的想法：
    基于Paxos的两阶段提交。
    用于快速只读事务的同步时间。
  在Google内部大量使用。

什么是激励用例？
  Google F1广告数据库（第5.4节）。
  之前分片在许多MySQL和BigTable数据库上；很尴尬。
  需要：
    更好的（同步）复制。
    更灵活的分片。
    跨分片事务。
  工作负载主要由只读事务主导（表6）。
  需要强一致性。
    外部一致性/线性化/序列化。

基本组织：
  数据中心A：
    "客户端"是Web服务器，例如用于gmail
    数据分片在多个服务器上：
      a-m
      n-z
  数据中心B：
    有自己的本地客户端
    和自己的数据分片副本
      a-m
      n-z
  数据中心C：
    相同设置

由Paxos管理复制；每个分片一个Paxos组。
  副本在不同的数据中心。
  类似于Raft -- 每个Paxos组有一个领导者。
  如同实验中，Paxos复制操作日志。

为什么这种安排？
  分片通过并行性允许巨大的总吞吐量。
  数据中心独立故障 -- 不同的城市。
  客户端可以读取本地副本 -- 快速！
  可以将副本放置在相关客户附近。
  Paxos只需要多数 -- 容忍缓慢/遥远的副本。

挑战是什么？
  本地副本的读取必须产生新鲜数据。
    但本地副本可能不反映最新的Paxos写入！
  事务可能涉及多个分片 -> 多个Paxos组。
  读取多个记录的事务必须是可序列化的。
    但本地分片可能反映不同子集的已提交事务！

Spanner区别对待读/写和只读事务。

首先，读/写事务。

读/写事务示例（银行转账）：
  BEGIN
    x = x + 1
    y = y - 1
  END
我们不希望任何对x或y的读或写在我们的两个操作之间偷偷发生。
提交后，所有读都应该看到我们的更新。

总结：与Paxos复制参与者的两阶段提交（2pc）。
  （暂时省略时间戳。）
  （这是用于读/写事务，不是只读。）
  客户端选择唯一的事务ID（TID）。
  客户端将每个读发送到相关分片的Paxos领导者（2.1）。
    每个分片首先获取相关记录的锁。
      可能需要等待。
    每个分片单独的锁表，在分片领导者中。
    读锁不通过Paxos复制，所以领导者故障 -> 中止。
    注意：永远不会有两个对等点认为它们是领导者，
      因为领导者租约（不相交不变量）
  客户端在提交前保持写入私有。
  当客户端提交时（4.2.1）：
    选择一个Paxos组作为2pc事务协调器（TC）。
    将写入发送到相关分片领导者。
    每个写入的分片领导者：
      获取写入记录的锁。
      通过Paxos记录"准备"记录，以复制锁和新值。
      告诉TC它准备好了。
      或者告诉TC"不"，如果崩溃因此丢失锁表。
  事务协调器：
    决定提交或中止。
    通过Paxos将决定记录到其组。
    告诉参与者领导者和客户端结果。
  每个参与者领导者：
    通过Paxos记录TC的决定。
    释放事务的锁。

关于设计迄今为止的一些要点。
  锁定（两阶段锁定）确保序列化。
  2pc被广泛憎恨，因为如果TC故障，它会阻塞并保持锁。
    用Paxos复制TC解决了这个问题！
  读/写事务需要很长时间。
    许多跨数据中心消息。
    表6表明跨美国读/写事务约100毫秒。
    跨城市少得多（表3）。
  但很多并行性：许多客户端，许多分片。
    所以如果忙碌，总吞吐量可能很高。

从现在开始我将主要将每个Paxos组视为单个实体。
  复制分片数据。
  复制两阶段提交状态。

现在是只读（r/o）事务。
  这些涉及多次读取，可能来自多个分片。
  我们希望只读事务比读/写事务快得多！

Spanner为只读事务消除了两个大成本：
  从本地副本读取，避免Paxos和跨数据中心消息。
    但注意本地副本可能不是最新的！
  没有锁，没有两阶段提交，没有事务管理器。
    再次避免向Paxos领导者发送跨数据中心消息。
    并且避免减慢读/写事务。
  表3和6因此显示10倍延迟改进！
  如何与正确性协调？

只读事务的正确性约束：
  可序列化：
    与事务逐个执行相同的结果。
      即使它们可能实际上并发执行。
    即只读事务必须基本上适合在读/写事务之间。
    看到来自先前事务的所有写入，没有来自后续的。
  外部一致：
    如果T1在T2开始前完成，T2必须看到T1的写入。
    "之前"指的是真实（墙钟）时间。
    类似于线性化。
    排除读取陈旧数据。

为什么不只读事务读取最新提交的值？
  假设我们有两个银行转账，和读取两者的事务。
    T1:  Wx  Wy  C
    T2:                 Wx  Wy  C
    T3:             Rx             Ry
  结果不会匹配任何序列顺序！
    不是T1, T2, T3。
    不是T1, T3, T2。
  我们希望T3看到T2的两个写入，或都不看到。
  我们希望T3的读取全部在相对于T1/T2的*相同*点发生。

想法：快照隔离（SI）：
  同步所有计算机的时钟（到真实墙钟时间）。
  为每个事务分配时间戳。
    读/写：提交时间。
    只读：开始时间。
  按时间戳顺序一次执行一个。
    即使实际读以不同顺序发生。
  每个副本存储每个记录的多个时间戳版本。
    读/写事务的所有写入获得相同的时间戳。
  只读事务的读看到事务时间戳的版本。
    时间戳小于事务时间戳的最高时间戳的记录版本。
  称为快照隔离。

我们的快照隔离例子：
                      x@10=9         x@20=8
                      y@10=11        y@20=12
    T1 @ 10:  Wx  Wy  C
    T2 @ 20:                 Wx  Wy  C
    T3 @ 15:             Rx             Ry
  "@ 10"表示时间戳。
  现在T3的读都将从@10版本提供服务。
    T3不会看到T2的写入，即使T3对y的读在T2之后发生。
  现在结果是可序列化的：T1 T2 T3
    序列顺序与时间戳顺序相同。

为什么T3可以读取y的*旧*值即使有新值？
  T2和T3是并发的，所以外部一致性允许任一顺序。
  记住：只读事务需要读取
    它们时间戳的值，并且*不*看到后来的写入。

问题：如果T3从还没有看到T1写入的副本读取x会怎样？
  因为副本不在Paxos多数中？

解决方案：副本"安全时间"。
  Paxos领导者按时间戳顺序发送写入。
  在服务时间20的读之前，副本必须看到时间> 20的Paxos写入。
    所以它知道它已经看到所有写入< 20。
  如果准备但未提交的事务也必须延迟（第4.1.3节）。
  因此：只读事务可以从本地副本读取 -- 通常快速。

问题：如果时钟没有完美同步会怎样？

如果时钟没有精确同步会出什么问题？
  读/写事务没有问题，它们使用锁。
  如果只读事务的TS太大：
    它的TS将高于副本安全时间，读将阻塞。
    正确但慢 -- 延迟增加时钟误差量。
  如果只读事务的TS太小：
    它将错过在只读事务开始前提交的写入。
    因为它的低TS将导致它使用记录的旧版本。
    这违反外部一致性。

如果只读事务的TS太小的例子：
  读/写 T0 @  0: Wx1 C
  读/写 T1 @ 10:         Wx2 C
  只读 T2 @  5:                   Rx?
（C表示提交）
这将导致T2读取时间0时x的版本，是1。
但T2在T1提交后开始（在实时中），
  所以外部一致性要求T2看到x=2。
所以必须有解决方案来处理不正确时钟的可能性！

我们能完美同步计算机时钟吗？
  以便每个计算机，在每个数据中心，都有相同的时间？
    即我们都同意是2020年4月7日星期二下午2:00。
  实践中不行，不能完美。
  时间由一些政府实验室的时钟定义。
  通过各种协议分发，例如GPS、WWV、NTP。
  分发延迟变化且难以预测。
  所以总是有不确定性。
  加上分发系统可能有故障，没有警告。

Google的时间参考系统（第5.3节）
  [UTC、GPS卫星、主服务器、服务器、TT区间]
  每个数据中心几个时间主服务器。
  每个时间主服务器有GPS接收器或"原子钟"。
  GPS接收器通常精确到小于一微秒。
  论文没有说原子钟是什么意思。
    可能同步到GPS，但在没有GPS一段时间内准确。
    如果滑行，误差累积，可能每周几微秒。
  其他服务器与几个附近的时间主服务器通信。
    由于网络延迟、检查间漂移的不确定性。

TrueTime
  时间服务产生TT区间 = [最早，最晚]。
  保证正确时间在区间内的某处。
  区间宽度从测量的网络延迟、
    时钟硬件规格计算。
  图6：区间通常是微秒，但有时10+毫秒。
  所以：服务器时钟没有精确同步，但TrueTime
    提供服务器时钟错误程度的保证界限。

Spanner如何确保如果读/写T1在只读T2开始前完成，TS1 < TS2。
  即只读事务时间戳不会太小。
  两个规则（4.1.2）：
  开始规则：
    事务TS = TT.now().latest
      对于只读，在开始时间
      对于读/写，在提交开始时
  提交等待，对于读/写事务：
    在提交前，延迟直到TS < TT.now().earliest
    保证TS已经过去。

用区间和提交等待更新的例子：
  情景是T1提交，然后T2开始，T2必须看到T1的写入。
  即我们需要TS1 < TS2。
  读/写 T0 @  1: Wx1 C
                   |1-----------10| |11--------------20|
  读/写 T1 @ 10:         Wx2 P          C
                                 |10--------12|
  只读 T2 @ 12:                           Rx?
在P（准备）时，读取now()，并为T1选择10（开始规则）作为TS
在C时，T1将继续读取now并等待直到10 < now().earliest（提交等待）
T2将在T1之后开始，当Rx读取now()时，它得到一个区间，
  必须包含10之后的时间（因为T2在T1之后开始）
  说(10,12)。T2选择12作为它的TS（开始规则）
  -> TS2 > TS1，并将看到TS1写入

由于提交等待，C保证在其TS（10）之后发生。
Rx根据假设在C之后发生，因此也在时间10之后。
T2选择TT.now().latest，它在当前时间之后，当前时间在10之后。
所以TS2 > TS1。

为什么这提供外部一致性：
  提交等待意味着读/写TS保证是过去。
  只读TS = TT.now().latest保证>=正确时间
    因此>=任何先前提交事务的TS（由于其提交等待）

更一般地：
  快照隔离给你可序列化的只读事务。
    时间戳设置顺序。
    快照版本（和安全时间）在时间戳实现一致读。
    事务看到来自低TS事务的所有写入，没有来自高TS的。
    如果你不关心外部一致性，任何数字都可以用于TS。
  同步时间戳产生外部一致性。
    即使在不同数据中心的事务之间。
    即使从可能滞后的本地副本读取。

为什么所有这些有用？
  快速只读事务：
    从客户端数据中心的副本读取。
    没有锁定，没有两阶段提交。
    因此表3和6中的10倍延迟改进。
  虽然：
    只读事务读可能由于安全时间阻塞，以追赶。
    读/写事务提交可能在提交等待中阻塞。
    准确（小区间）时间最小化这些延迟。

总结：
  很少看到部署系统提供分布式事务
    在地理分布的数据上。
  Spanner是一个令人惊讶的演示，它可以实用。
  时间戳方案是最有趣的方面。
  在Google内部广泛使用；Google商业服务；有影响力。

---

Spanner：成为SQL系统，2017年，https://research.google/pubs/pub46103.pdf