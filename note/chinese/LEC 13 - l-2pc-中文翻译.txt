6.824 2021 第13讲：分布式事务

主题：
  分布式事务 = 并发控制 + 原子提交

问题是什么？
  大量数据记录，分片在多个服务器上，大量客户端
  [图表：客户端、服务器、按键分片的数据]
  客户端应用程序操作通常涉及多次读取和写入
    银行转账：借记和贷记
    投票：检查是否已投票，记录投票，增加计数
    在社交图中安装双向链接
  我们希望对应用程序编写者隐藏交错和故障
  这是传统的数据库关注点
    今天的材料源于数据库
    但这些思想在许多分布式系统中使用

传统计划：事务
  程序员标记代码序列的开始/结束为事务

事务示例
  x和y是银行余额--数据库表中的记录
  x和y在不同的服务器上（可能在不同的银行）
  x和y开始时都是10美元
  T1和T2是事务
    T1：从x转账1美元到y
    T2：审计，检查没有钱丢失
  T1:             T2:
  begin_xaction   begin_xaction
    add(x, 1)       tmp1 = get(x)
    add(y, -1)      tmp2 = get(y)
  end_xaction       print tmp1, tmp2
                  end_xaction

事务的正确行为是什么？
  通常称为"ACID"
    原子性--要么全部写入要么全不写入，尽管有故障
    一致性--服从应用程序特定的不变量
    隔离性--事务之间没有干扰--可序列化
    持久性--已提交的写入是永久的
  我们对分布式事务的ACID感兴趣
    数据分片在多个服务器上

可序列化是什么意思？
  你执行一些并发事务，产生结果
    "结果"意味着输出和数据库中的更改
  结果是可序列化的，如果：
    存在一个事务的串行执行顺序
    产生与实际执行相同的结果
  （串行意味着一次一个--没有并行执行）
  （这个定义应该让你想起线性化）

你可以通过寻找产生相同结果的顺序来测试执行结果是否可序列化。
  对于我们的例子，可能的串行顺序是
    T1; T2
    T2; T1
  所以正确（可序列化）的结果是：
    T1; T2 : x=11 y=9 "11,9"
    T2; T1 : x=11 y=9 "10,10"
  两个的结果不同；任何一个都可以
  没有其他结果是可接受的
  实现可能并行执行T1和T2
    但它必须仍然产生按串行顺序的结果

如果T1的操作完全在T2的两个get()之间运行会怎样？
  结果会是可序列化的吗？
  T2会打印10,9
  但10,9不是两个可序列化结果之一！
如果T2完全在T1的两个add()之间运行会怎样？
  T2会打印11,10
  但11,10不是两个可序列化结果之一！
如果x的服务器执行增量但y的服务器故障会怎样？
  x=11 y=10不是两个可序列化结果之一！

为什么序列化很受欢迎
  对程序员来说是一个简单的模型
    他们可以编写复杂的事务而忽略并发性
  它允许在不同记录上并行执行事务

如果出现问题，事务可以"中止"
  中止撤销任何记录修改
  事务可能自愿中止，
    例如，如果账户不存在，或者y的余额<= 0
  系统可能强制中止，例如打破锁定死锁
  一些服务器故障导致中止
  应用程序可能（也可能不）再次尝试事务

分布式事务有两个主要组成部分：
  并发控制（提供隔离性/序列化）
  原子提交（尽管故障提供原子性）

首先，并发控制
  并发事务的正确执行

事务的并发控制的两类：
  悲观：
    在使用前锁定记录
    冲突导致延迟（等待锁）
  乐观：
    不锁定使用记录
    提交检查读/写是否可序列化
    冲突导致中止+重试
    称为乐观并发控制（OCC）
  如果冲突频繁，悲观更快
  如果冲突很少，乐观更快

今天：悲观并发控制
下周：乐观并发控制（FaRM）

"两阶段锁定"是实现序列化的一种方式
  2PL定义：
    事务必须在使用记录前获取记录的锁
    事务必须保持其锁直到提交或中止*之后*

我们例子的2PL
  假设T1和T2同时开始
  事务系统根据需要自动获取锁
  所以T1/T2中第一个使用x的将获得锁
  另一个等待第一个完全完成
  这禁止了不可序列化的交错

细节：
  每个数据库记录都有一个锁
  如果是分布式的，锁通常存储在记录的服务器上
    [图表：客户端、服务器、记录、锁]
    （但两阶段锁定不受分布的影响很大）
  执行中的事务根据需要在首次使用时获取锁
    add()和get()隐式获取记录的锁
    end_xaction()释放所有锁
  所有锁都是排他的（在本讨论中，没有读/写锁）
  全名是"强严格两阶段锁定"
  与线程锁定相关（例如Go的Mutex），但更容易：
    显式的begin/end_xaction
    DB自动锁定，在每个记录的首次使用时
    DB自动解锁，在事务结束时
    DB可能自动中止以治愈死锁

为什么保持锁直到提交/中止之后？
  为什么不在完成记录后立即释放？
  由此产生的问题示例：
    假设T2在get(x)后释放x的锁
    T1然后可以在T2的两个get()之间执行
    T2会打印10,9
    糟糕：这不是可序列化的执行：既不是T1;T2也不是T2;T1
  由此产生的问题示例：
    假设T1写入x，然后释放x的锁
    T2读取x并打印
    T1然后中止
    糟糕：T2使用了一个从未真正存在的值
    我们应该中止T2，这将是"级联中止"；尴尬

两阶段锁定可能产生死锁，例如
  T1      T2
  get(x)  get(y)
  get(y)  get(x)
系统必须检测（循环？锁超时？）并中止一个事务

2PL是否会禁止正确（可序列化）的执行？
  是的；例子：
    T1        T2
    get(x)
              get(x)
              put(x,2)
    put(x,1)
  锁定会禁止这种交错
  但结果（x=1）是可序列化的（与T2;T1相同）

问题：描述一种两阶段锁定比简单锁定性能更高的情况。
简单锁定：在*任何*使用前锁定*每个*记录；在中止/提交后释放。

下一个主题：分布式事务与故障

分布式事务如何处理故障？
  假设，对于我们的例子，x和y在不同的"工作进程"服务器上
  假设x的服务器加1，但y的服务器在减法前崩溃？
  或者x的服务器加1，但y的服务器意识到账户不存在？
  或者x和y都可以做它们的部件，但不确定对方是否可以？

我们需要"原子提交"：
  一群计算机正在协作某个任务
  每台计算机有不同的角色
  希望确保原子性：全部执行，或都不执行
  挑战：故障、性能

我们将开发一个称为"两阶段提交"的协议
  分布式数据库用于多服务器事务

设置
  数据分片在多个服务器上
  事务在"事务协调器"（TC）上运行
  对于每次读/写，TC向相关分片服务器发送RPC
    每都是一个"参与者"
    每个参与者管理其数据分片的锁
  可能有许多并发事务，许多TC
    TC为每个事务分配唯一的事务ID（TID）
    每条消息，每个表条目都标记TID
    以避免混淆

没有故障的两阶段提交：
  [时间图：TC、A、B]
  TC向A、B发送put()、get()等RPC
    修改是暂时的，只有在提交时才安装。
  TC到达事务结束时。
  TC向A和B发送PREPARE消息。
  如果A愿意提交，
    A响应YES。
    然后A处于"已准备"状态。
  否则，A响应NO。
  B相同。
  如果A和B都说YES，TC向A和B发送COMMIT消息。
  如果A或B说NO，TC发送ABORT消息。
  如果A/B从TC获得COMMIT消息，它们提交。
    即，它们将临时记录写入真实数据库。
    并释放它们记录上事务的锁。
  A/B确认COMMIT消息。

为什么到目前为止这是正确的？
  除非A和B都同意，否则A或B都不能提交。

如果B崩溃并重启会怎样？
  如果B在崩溃前发送了YES，B必须记住（尽管崩溃）！
  因为A可能已经收到COMMIT并提交。
  所以B必须即使重启后也能提交（或不提交）。

因此参与者必须写入持久（磁盘）状态：
  B必须在说YES之前记住在磁盘上，包括修改的数据。
  如果B重启，磁盘显示YES但没有COMMIT，
    B必须询问TC，或等待TC重新发送。
  同时，B必须继续保持事务的锁。
  如果TC说COMMIT，B将修改的数据复制到真实数据。

如果TC崩溃并重启会怎样？
  如果TC可能在崩溃前发送了COMMIT，TC必须记住！
    因为一个工作进程可能已经提交。
  因此TC必须在发送COMMIT消息前将COMMIT写入磁盘。
  如果崩溃并重启，或者如果参与者询问（即如果A/B没有收到COMMIT消息），重复COMMIT。
  参与者必须过滤重复的COMMIT（使用TID）。

如果TC从未从B获得YES/NO会怎样？
  也许B崩溃并且没有恢复；也许网络中断。
  TC可以超时，并中止（因为还没有发送任何COMMIT消息）。
  好：允许服务器释放锁。

如果B在等待来自TC的PREPARE时超时或崩溃会怎样？
  B还没有响应PREPARE，所以TC不能决定提交
  所以B可以单方面中止，并释放锁
  对未来的PREPARE响应NO

如果B对PREPARE响应YES，但没有收到COMMIT或ABORT会怎样？
  B可以单方面决定中止吗？
    不！TC可能已经从两者那里获得YES，
    并且向A发送了COMMIT，但在发送给B之前崩溃。
    那么A会提交而B会中止：不正确。
  B也不能单方面提交：
    A可能投了NO。

所以：如果B投了YES，它必须"阻塞"：等待TC决定。

注意：
  提交/中止决定由单个实体--TC做出。
  这使两阶段提交相对简单。
  代价是A/B在投YES后必须等待TC。

TC何时可以完全忘记已提交的事务？
  如果它看到每个参与者对COMMIT的确认。
  那么没有参与者会再需要询问。

参与者何时可以完全忘记已提交的事务？
  在它确认TC的COMMIT消息后。
  如果它得到另一个COMMIT，并且没有事务记录，
    它必须已经提交并忘记，并且可以确认（再次）。

两阶段提交视角
  当事务使用多个分片上的数据时，在分片数据库中使用
  但它名声不好：
    慢：多轮消息
    慢：磁盘写入
    锁在准备/提交交换期间保持；阻塞其他事务
    TC崩溃可能导致无限阻塞，保持锁
  因此通常只在单个小域中使用
    例如，不在银行之间，不在航空公司之间，不在广域网上
  更快的分布式事务是一个活跃的研究领域。

Raft和两阶段提交解决不同的问题！
  使用Raft通过复制获得高可用性
    即能够在一些服务器崩溃时操作
    服务器都做*相同*的事情
  当每个参与者做不同的事情时使用2PC
    并且*所有*它们都必须做它们的部件
  2PC不能帮助可用性
    因为所有服务器都必须正常运行才能完成任何事情
  Raft不确保所有服务器都做某事
    因为只需要多数是活跃的

如果你想要高可用性*和*原子提交会怎样？
  这是一个计划。
  [图表]
  TC和服务器都应该用Raft复制
  在复制服务之间运行两阶段提交
  然后你可以容忍故障并仍然取得进展
  你将在实验4中构建类似这样的东西来转移分片
  下次会议的Spanner使用这种安排

---

http://dbmsmusings.blogspot.com/2019/01/its-time-to-move-on-from-two-phase.html