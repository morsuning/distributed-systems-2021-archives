ZooKeeper FAQ

问：为什么只有更新请求是A-线性化的？为什么读取不是？

答：作者希望高总读取吞吐量，所以他们希望副本能够满足客户端读取而不涉及领导者。给定副本可能不知道已提交的写入（如果它不在领导者等待的多数中），或者可能知道写入但还不知道它是否已提交。因此副本的状态可能落后于领导者和其他副本。因此从副本提供读取可能产生不反映最近写入的数据——即，读取可以返回陈旧结果。

问：线性化和可串行化有什么区别？

答：可串行化的通常定义很像线性化，但没有操作尊重实时排序的要求。看看这个解释：
http://www.bailis.org/blog/linearizability-versus-serializability/

ZooKeeper论文的第2.3节使用"可串行化"来表示系统行为就像写入（来自所有客户端的组合）按某种顺序一个接一个执行。"FIFO客户端顺序"属性意味着读取在写入顺序中的特定点发生，并且给定客户端的连续读取在该顺序中永不向后移动。这里发生的一件事是写入和读取的保证是不同的。

问：什么是流水线？

这里有两件事在进行。首先，ZooKeeper领导者（实际上是领导者的Zab层）将多个客户端操作批处理在一起，以便在网络和磁盘上高效地发送和写入。对于网络和磁盘，一次性发送N个小项目的批处理通常比一个一个地发送或写入更有效。这种批处理只有在领导者同时看到许多客户端请求时才有效；所以它取决于有大量活跃客户端。

流水线的第二个方面是ZooKeeper使每个客户端可以很容易地同时保持许多写请求未完成，通过支持异步操作。从客户端的角度来看，它可以发送大量写请求而无需等待响应（响应稍后到达，作为写入提交后的通知）。从领导者的角度来看，那种客户端行为给领导者大量请求积累成大的高效批处理。

流水线的一个担忧是正在进行的操作可能被重新排序，这将导致作者在2.3节中谈论的问题。如果领导者有许多正在进行的写操作后跟对ready的写入，你不希望那些操作被重新排序，因为其他客户端可能在前面写入应用之前观察到ready。为确保这不会发生，ZooKeeper保证客户端操作的FIFO；即客户端操作按它们发出的顺序应用。

问：无等待是什么意思？

答：精确定义：并发数据对象的无等待实现是保证任何进程都可以在有限步骤内完成任何操作，无论其他进程的执行速度如何。这个定义在Herlihy的以下论文中引入：
https://cs.brown.edu/~mph/Herlihy91/p124-herlihy.pdf

Zookeeper是无等待的，因为它处理一个客户端的请求而不需要等待其他客户端采取行动。这部分是API的结果：尽管设计为支持客户端/客户端协调和同步，但没有ZooKeeper API调用的定义方式需要等待另一个客户端。相比之下，支持等待当前锁持有者释放锁的锁获取操作的系统不会是无等待的。

然而，最终ZooKeeper客户端通常需要相互等待，ZooKeeper确实提供等待机制——监视器。无等待对API的主要影响是监视器从其他操作中分离出来。原子测试和设置更新（例如文件创建和基于版本的写入）与监视器的结合允许客户端合成更复杂的阻塞抽象（例如第2.4节的锁和屏障）。

问：领导者如何知道客户端希望一批异步更新执行的顺序？

答：论文没有说。答案可能涉及客户端对其异步请求编号，以及领导者为每个客户端（实际上是会话）跟踪它接下来应该期望什么编号。领导者无论如何都必须保持每个会话的状态（用于客户端会话超时），所以跟踪每个会话请求序列号可能工作量很小。这些信息必须在领导者失败和另一个服务器接管时保留，所以客户端序列号可能在复制日志条目中传递。

问：如果客户端没有收到请求的回复怎么办？它会重新发送吗，以防网络丢失请求或回复，或者领导者在提交前崩溃？ZooKeeper如何避免重新发送导致重复执行？

答：论文没有说这是如何工作的。可能领导者跟踪从每个会话收到和提交的请求编号，以便它可以过滤掉重复请求。实验3有类似的安排。

问：如果客户端提交异步写入，然后立即进行读取，读取会看到写入的效果吗？

答：论文没有明确说，但第2.3节"FIFO客户端顺序"属性的暗示是读取会看到写入。这似乎意味着服务器可能阻塞读取，直到服务器从领导者收到客户端所有先前写入。ZooKeeper可能通过让客户端在其读取请求中发送客户端提交的最新先前操作的zxid来管理这个问题。

问：实现'模糊快照'的原因是什么？

答：精确快照对应于日志中的特定点：快照将包括该点之前的每个写入，不包括该点之后的任何写入；并且在重启后清楚地知道从哪里开始重放日志条目以使快照更新。然而，创建精确快照需要一种在创建快照并将其写入磁盘时防止任何写入发生的方法。在快照创建期间阻塞写入会大大降低性能。

ZooKeeper的模糊快照的要点是ZooKeeper从其内存数据库创建快照，同时允许对数据库进行写入。这意味着快照不对应于日志中的特定点——快照包括与快照创建并发的写入的或多或少随机子集。重启后，ZooKeeper通过重放从快照开始点开始的所有日志条目来构建一致的快照。因为Zookeeper中的更新是幂等的并且以相同顺序传递，应用程序状态在重启和重放后将是正确的——一些消息可能被应用两次（一次在恢复前的状态，一次在恢复后），但没关系，因为它们是幂等的。重放将模糊快照修复为应用程序状态的一致快照。

Zookeeper领导者将客户端API中的操作转换为幂等事务。例如，如果客户端发出条件setData并且请求中的版本号匹配，Zookeeper领导者创建一个包含新数据、新版本号和更新时间戳的setDataTXN。这个事务（TXN）是幂等的：Zookeeper可以执行它两次，它将产生相同的状态。

问：ZooKeeper如何选择领导者？

答：Zookeeper使用ZAB，一个原子广播系统，它内置了领导者选举，很像Raft。这里是关于Zab的论文：
http://dl.acm.org/citation.cfm?id=2056409

问：Zookeeper的性能与其他系统如Paxos相比如何？

答：它有令人印象深刻的性能（特别是吞吐量）；Zookeeper会大大击败你的Raft实现。3个zookeeper服务器每秒处理21,000次写入。你的有3个服务器的raft每秒提交大约几十个操作（假设使用磁性磁盘存储），使用SSD可能每秒几百个。

问：顺序保证如何解决第2.3节中的竞争条件？

如果客户端向各种z节点发出许多写操作，然后向Ready写入，那么Zookeeper将保证所有写入将在向Ready写入之前应用到z节点。因此，如果另一个客户端观察到Ready，那么所有前面的写入必须已经应用，因此客户端读取z节点中的信息是可以的。

问：ZooKeeper数据库有多大？似乎服务器必须有很多内存。

这取决于应用程序，不幸的是，论文没有报告作者在这方面的经验。由于Zookeeper用于配置和协调，而不是通用数据存储，内存数据库似乎是合理的。例如，你可以想象将Zookeeper用于GFS的主控，那么数量的数据应该适合装备良好的服务器的内存，就像GFS那样。

问：什么是通用对象？

答：这是基于Herlihy引入的并发对象理论对Zookeeper API有多好的理论陈述：
https://cs.brown.edu/~mph/Herlihy91/p124-herlihy.pdf。我们不会在这个陈述和理论上花费任何时间，但如果你关心，这个维基百科页面有温和的介绍：
https://en.wikipedia.org/wiki/Non-blocking_algorithm。

作者诉诸这个并发对象理论以显示Zookeeper的API是通用的：API包括足够的特性来实现你想要的任何协调方案。

问：客户端如何知道何时离开屏障（第7页顶部）？

答：离开屏障涉及每个客户端监视参与屏障的所有其他客户端的z节点。每个客户端等待所有它们都消失。如果它们都消失了，它们离开屏障并继续计算。

问：是否可以在不将服务停机一段时间的情况下向现有ZooKeeper添加更多服务器？

是的——虽然在原始论文发表时，集群成员是静态的。现在，ZooKeeper支持"动态重新配置"：

https://zookeeper.apache.org/doc/r3.5.3-beta/zookeeperReconfig.html

...实际上还有一篇描述机制的论文：

https://www.usenix.org/system/files/conference/atc12/atc12-final74.pdf

你认为这与两年后出现的Raft通过重叠共识的动态配置更改相比如何？

问：监视器在客户端库中是如何实现的？

这取决于实现。在大多数情况下，客户端库可能注册一个在监视器触发时将被调用的回调函数。

例如，ZooKeeper的Go客户端通过将通道传递到"GetW()"（带监视器的获取）来实现它；当监视器触发时，"Event"结构通过通道发送。应用程序可以在select子句中检查通道。

参见https://godoc.org/github.com/samuel/go-zookeeper/zk#Conn.GetW。

问：第6页代码中的读锁为什么像写锁那样跳转到第2行而不是第3行？

答：很好的发现；我相信这是一个错误。正确的配方在这里：
https://zookeeper.apache.org/doc/r3.1.2/recipes.html#Shared+Locks

问：作者为什么选择ZooKeeper这个名字？

答：apache zookeeper网站这样说："ZooKeeper: Because Coordinating Distributed Systems is a Zoo"