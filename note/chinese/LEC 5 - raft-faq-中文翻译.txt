Raft 常见问题

问：Raft为简单性牺牲了什么？

答：Raft牺牲了一些性能来换取清晰度；例如：

* 每个操作必须写入磁盘进行持久化；性能可能需要将许多操作批量处理到每个磁盘写入中。

* 从领导人到每个追随者只能有效地有一个AppendEntries在传输中：追随者拒绝乱序的AppendEntries，发送者的nextIndex[]机制要求一次一个。为流水线化多个AppendEntries提供的条款会更好。

* 快照设计只对相对较小的状态实用，因为它将整个状态写入磁盘。如果状态很大（例如，如果它是一个大型数据库），你会想要一种只写入最近更改的部分状态的方法。

* 类似地，通过发送完整快照来使恢复副本更新到最新状态会很慢，如果副本已经有旧快照就更不必要了。

* 服务器可能无法充分利用多核，因为操作必须按顺序执行（按日志顺序）。

这些可以通过修改Raft来修复，但结果作为教程的价值可能较小。

问：Raft是否用于现实世界的软件，还是公司通常推出自己的Paxos风格（或使用不同的共识协议）？

答：有几个Raft的现实世界用户：Docker（https://docs.docker.com/engine/swarm/raft/）、etcd（https://etcd.io）和MongoDB。其他据说使用Raft的系统包括CockroachDB、RethinkDB和TiKV。也许你可以从http://raft.github.io/开始找到更多

另一方面，我的印象是大多数状态机复制系统基于Multi-Paxos和Viewstamped复制协议。

问：什么是Paxos？在什么意义上Raft更简单？

答：有一个叫做Paxos的协议，允许一组服务器就单个值达成一致。虽然Paxos需要一些思考来理解，但它比Raft简单得多。这是一篇关于Paxos的易读论文：

  http://css.csail.mit.edu/6.824/2014/papers/paxos-simple.pdf

然而，Paxos解决的问题比Raft小得多。要构建一个现实世界的复制服务，副本需要就无限序列的值（客户端命令）达成一致，并且它们需要有效恢复当服务器崩溃重启或丢失消息时。人们已经以Paxos为起点构建了这样的系统；查看Google的Chubby和Paxos Made Live论文，以及ZooKeeper/ZAB。还有一个叫做Viewstamped复制的协议；它是一个好的设计，类似于Raft，但关于它的论文难以理解。

这些现实世界的协议很复杂，并且（在Raft之前）没有好的入门论文描述它们如何工作。相比之下，Raft论文相对容易阅读且相当详细。这是一个很大的贡献。

Raft协议是否本质上比其他协议更容易理解尚不清楚。这个问题由于缺乏其他现实世界协议的良好描述而变得模糊。此外，Raft在多个方面为清晰度牺牲了性能；这对教程来说很好，但在现实世界协议中并不总是理想。

问：在作者创建Raft之前，Paxos存在了多长时间？

答：Paxos发明于1980年代末。Raft开发于2012年左右。

Raft与一个叫做Viewstamped Replication的协议非常相似，最初发表于1988年。在1990年代初有构建在Viewstamped Replication之上的复制容错文件服务器，但没有在生产中使用。

许多现实世界系统源自Paxos：Chubby、Spanner、Megastore和Zookeeper/ZAB。从2000年代初开始，大型网站和云提供商需要容错服务，Paxos在那时或多或少被重新发现并投入生产使用。

问：在现实世界应用中，Raft的性能与Paxos相比如何？

答：最快的Paxos衍生协议可能比论文中描述的Raft更快；看看ZAB/ZooKeeper和Paxos Made Live。另一方面，etcd3（使用Raft）声称比zookeeper和许多基于Paxos的实现取得了更好的性能（https://www.youtube.com/watch?v=hQigKX0MxPw）。

有些情况下Raft的领导人不是那么好。如果包含副本和客户端的数据中心彼此相距很远，人们有时使用源自原始Paxos的协议。原因是Paxos没有领导人；任何副本都可以开始协议；所以客户端可以与他们本地数据中心中的副本交谈，而不必与远程数据中心中的领导人交谈。ePaxos是一个例子。

问：为什么我们学习/实现Raft而不是Paxos？

答：我们在6.824中使用Raft是因为有一篇论文清楚地描述了如何使用Raft构建完整的复制服务。我知道没有令人满意的论文描述如何构建基于Paxos的完整复制服务器系统。

问：是否有像Raft这样的系统可以在只有少数集群活跃时存活并继续操作？

答：不适用于Raft的属性。但你可以在不同的假设或不同的客户端可见语义下做到这一点。基本问题是脑裂——状态多个分歧副本的可能性，由副本的多个子集在不知道彼此的情况下改变状态引起。我知道有两种解决方案。

如果以某种方式客户端和服务器可以确切知道哪些服务器存活，哪些死亡（相对于存活但由于网络故障而无法访问），那么可以构建一个只要有一个存活就能运行的系统，选择（比如说）已知存活的最低编号服务器。然而，一台计算机很难决定另一台计算机是否死了，相对于网络丢失它们之间的消息。一种方法是让人来决定——人可以检查每台服务器并决定哪些存活哪些死亡。

另一种方法是允许脑裂操作，并有一种方法让服务器在分区愈合后协调产生的分歧状态。这可以为某些类型的服务工作，但有复杂的客户端可见语义（通常称为"最终一致性"）。看看课程后面分配的COPS、FuzzyLog和Bitcoin论文。

问：在Raft中，被复制的服务在选举过程中对客户端不可用。这在实践中造成多大问题？

答：客户端可见的暂停似乎可能在十分之一秒的量级。作者期望故障（从而选举）是罕见的，因为它们只在机器或网络故障时发生。许多服务器和网络连续运行数月甚至数年，所以这对许多应用程序来说似乎不是一个大问题。

问：是否有其他没有领导人选举暂停的共识系统？

答：有基于Paxos的复制版本没有领导人或选举，因此在选举期间不会遭受暂停。相反，任何服务器都可以在任何时候有效地充当领导人。没有领导人的代价是每个协议需要更多的消息。

问：Raft和VMware FT有什么关系？

答：Raft没有单点故障，而VMware FT确实有测试和设置服务器形式的单点故障。从这个意义上说，Raft比VMware FT更根本地容错。可以通过使用Raft或Paxos将FT的测试和设置服务器实现为复制服务来修复这个问题。

VMware-FT可以复制任何虚拟机客户机，从而任何服务器式软件。Raft只能复制专门为Raft复制设计的软件。对于这样的软件，Raft可能比VMware-FT更高效。

问：为什么恶意人员不能接管Raft服务器，或伪造错误的Raft消息？

答：Raft不包括对此类攻击的防御。它假设所有参与者都遵循协议，并且只有正确集合的服务器参与。

现实部署必须防止恶意攻击者。最直接的选择是将服务器放在防火墙后面，过滤掉来自互联网上随机人员的数据包，并确保防火墙内的所有计算机和人员都是可信的。

可能存在Raft必须与潜在攻击者在同一网络上运行的情况。在这种情况下，好的计划是用一些密码方案验证Raft数据包。例如，给每个合法的Raft服务器一个公/私钥对，让它签名它发送的所有数据包，给每个服务器一个合法Raft服务器的公钥列表，让服务器忽略不是该列表上密钥签名的数据包。

问：论文提到Raft在所有非拜占庭条件下工作。什么是拜占庭条件，为什么它们会使Raft失败？

答："非拜占庭条件"意味着服务器是故障停止的：它们要么正确遵循Raft协议，要么停止。例如，大多数电源故障是非拜占庭的，因为它们导致计算机简单地停止执行指令；如果发生电源故障，Raft可能停止操作，但它不会向客户端发送错误结果。

拜占庭故障指的是一些计算机执行错误的情况，因为缺陷或有人恶意控制计算机。如果发生这样的故障，Raft可能向客户端发送错误结果。

6.824的大部分是关于容忍非拜占庭故障。尽管拜占庭故障仍正确操作更困难；我们将在学期末触及这个主题。

问：在图1中，客户端和服务器之间的接口是什么样的？

答：通常是到服务器的RPC接口。对于像你将在实验3中构建的键/值存储服务器，它是Put(key,value)和Get(value) RPC。RPC由服务器中的键/值模块处理，该模块调用Raft.Start()要求Raft将客户端RPC放入日志，并读取applyCh以了解新提交的日志条目。

问：如果客户端向领导人发送请求，但领导人在向所有追随者发送客户端请求之前崩溃，并且新领导人没有请求在其日志中，那会不会导致客户端请求丢失？

答：是的，请求可能丢失。如果日志条目没有提交，Raft可能不会在领导人变更中保留它。

这没关系，因为如果Raft没有提交请求，客户端不可能收到对其请求的回复。客户端会知道（通过看到超时或领导人变更）它的请求可能丢失了，并将重新发送它。

客户端可以重新发送请求的事实意味着系统必须防范重复请求；你将在实验3中处理这个问题。

问：如果有网络分区，Raft最终会有两个领导人和脑裂吗？

答：不。最多只能有一个活跃的领导人。

新领导人只有在能通过RequestVote RPC联系多数服务器（包括自己）时才能被选举。所以如果有分区，并且其中一个分区包含多数服务器，那个分区可以选举新领导人。其他分区必须是少数，所以它们不能选举领导人。如果没有多数分区，就没有领导人（直到有人修复网络分区）。

问：假设在网络分区时选举了新领导人，但旧领导人在不同的分区中。旧领导人将如何知道停止提交新条目？

答：旧领导人要么无法获得对其AppendEntries RPC的多数成功响应（如果它在少数分区中），要么如果它能与多数交谈，那个多数必须与新领导人的多数重叠，重叠中的服务器将告诉旧领导人有更高的任期。这将导致旧领导人切换到追随者。

问：当一些服务器故障时，"多数"是指存活服务器的多数，还是所有服务器（包括死的）的多数？

答：总是所有服务器的多数。所以如果总共有5个Raft对等方，但两个故障，候选人仍必须得到3票（包括自己）才能被选为领导人。

这有很多原因。可能是两个"故障"服务器实际上在不同的分区中运行。从它们的角度来看，有三个故障服务器。如果允许它们只用两票（仅来自两个看起来存活的服务器）选举领导人，我们会得到脑裂。另一个原因是我们需要任何两个领导人的多数在至少一个服务器上重叠，以保证新领导人看到先前的任期号和先前任期中提交的任何日志条目；这需要所有服务器（死和活）的多数。

问：如果选举超时太短怎么办？那会导致Raft故障吗？

答：选举超时的错误选择不影响安全性，只影响活性。

如果选举超时太小，那么追随者可能在领导人有机会发送任何AppendEntries之前反复超时。在这种情况下Raft可能花费所有时间选举新领导人，没有时间处理客户端请求。如果选举超时太大，那么在领导人故障后会有不必要的长暂停，然后才选举新领导人。

问：为什么随机化选举超时？

答：为了减少两个对等方同时成为候选人并在他们之间均匀分割选票的机会，阻止任何人被选举。

问：候选人可以在收到多数票后立即宣布自己为领导人，而不麻烦等待进一步的RequestVote回复吗？

答：可以——多数就足够了。等待更久将是一个错误，因为一些对等方可能故障因此永远不会回复。

问：Raft假设什么网络？

答：网络不可靠：它可能丢失请求和回复并延迟它们。Raft的RPC库不提供可靠性；它是尽力而为的（例如，它发送请求但网络可能丢弃它）。实验的RPC库提供类似的语义：它可能丢失请求、丢失回复、延迟消息，并完全断开特定主机。

问：requestVote RPC中votedFor检查的目的是什么？特别是，如果候选人不重试RPC？（即，如果重新开始新选举，它增加任期所以不会有重复RPC）。

答：两个候选人可能大约同时为新任期开始选举。追随者应该只为其中之一投票。

问：Raft中的领导人除了崩溃外还能停止成为领导人吗？

答：可以。如果领导人的CPU很慢，或其网络连接中断，或丢失太多数据包，或传递数据包太慢，其他服务器将看不到它的AppendEntries RPC，并将开始选举。

问：追随者的日志条目何时发送到它们的状态机？

答：只有在领导人使用AppendEntries RPC的leaderCommit字段说条目已提交之后。那时追随者可以执行（或应用）日志条目，对我们来说这意味着在applyCh上发送它。

问：领导人应该等待AppendEntries RPC的回复吗？

答：领导人应该并发发送AppendEntries RPC，不等待。随着回复回来，领导人应该计算它们，并且只有在收到多数服务器（包括自己）的回复时才将日志条目标记为已提交。

在Go中做到这一点的一种方法是领导人在单独的goroutine中发送每个AppendEntries RPC，这样领导人并发发送RPC。像这样：

  for each server {
    go func() {
      send the AppendEntries RPC and wait for the reply
      if reply.success == true {
        increment count
        if count == nservers/2 + 1 {
          this entry is committed
        }
      }
    } ()
  }

问：如果一半（或更多）服务器死了会发生什么？

答：服务无法取得任何进展；它将一遍又一遍地尝试选举领导人。如果/当足够多的服务器带着持久Raft状态完整地恢复生命，它们将能够选举领导人并继续。

问：为什么Raft日志是1索引的？

答：你应该将其视为零索引的，但以一个条目（在index=0处）开始，该条目有term 0。这允许第一个AppendEntries RPC包含0作为PrevLogIndex，并且是日志的有效索引。

问：当网络分区发生时，少数分区中的客户端请求不会丢失吗？

答：是的，只有拥有多数服务器的分区可以提交和执行客户端操作。少数分区中的服务器无法提交客户端操作，所以它们不会回复客户端请求。客户端将一直重新发送请求，直到它们能联系多数Raft分区。

问：5.4.3中的论点是完整的证明吗？

答：5.4.3不是完整的证明。这里有一些地方可以看：

http://ramcloud.stanford.edu/~ongaro/thesis.pdf
http://verdi.uwplse.org/raft-proof.pdf

问：在Raft之上构建应用程序有什么限制吗？

答：我认为为了干净地融入像Raft这样的复制状态机框架，复制服务必须是自包含的——它可以有私有状态，接受更新状态的客户端命令，但它不能在没有特殊预防措施的情况下联系外部实体。如果复制应用程序与外部世界交互，外部世界必须能够正确处理重复请求（由于复制和重启后日志的重放），并且它必须从不自相矛盾（即它必须小心向所有副本和所有日志条目的重新执行发送完全相同的答案）。这反过来似乎要求Raft应用程序联系的任何外部实体本身必须是容错的，即可能必须使用Raft或类似的东西。这相当有限。

作为一个例子，想象一个复制的在线订购系统向某个外部信用卡处理服务发送信用卡收费请求。那个外部处理器将看到重复请求（来自每个副本一个或多个）。它会以完全相同的方式响应每个请求吗？它会多次收费信用卡吗？如果它做了正确的事情，如果它在尴尬时刻崩溃并重启，它还会做正确的事情吗？

问：为什么叫Raft？

答：https://groups.google.com/g/raft-dev/c/95rZqptGpmU