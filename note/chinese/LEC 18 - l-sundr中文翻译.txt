6.824 2021 第18讲：安全不可信数据存储库（SUNDR）(2004)

为什么要读这篇论文？
- Frangipani的逻辑泛化，但具有更强的威胁模型：完全受损的（"拜占庭"）服务器。
- 在不可信服务器上实现安全性的强大技术。
- 不仅仅是文件系统。
- 类似思想出现在去中心化系统、git、区块链等中。
- Keybase（被zoom收购）直接受SUNDR影响。
- 与6.858的交集
  - 解决方案需要签名、哈希等。
  - [6.858的实验5]

设置背景：
- 网络文件服务器。
  - 想象云存储服务，如Dropbox/Google Drive/...
  - 但服务器主要是一个块存储；客户端实现文件系统。
  - 类似Frangipani。
- 通过网络访问文件的客户端。
  - RPC协议。
- 服务器是"拜占庭"的。
  - 完全由对手控制。
  - 可以以对手选择的任何方式响应客户端RPC。
  - 甚至可能与受损用户串通。
  - ..但受密码学约束：
    - 不能伪造未受损用户的签名。
- 强大的威胁模型：涵盖广泛的可能真实攻击。
  - 服务器软件中的漏洞。
  - 具有弱密码的管理员。
  - 数据中心的物理入侵。
  - 恶意或被贿赂的服务器操作员。

潜在目标：
- 机密性。
  - 对手无法获取文件内容。
- 完整性。
  - 对手无法欺骗客户端获取错误的文件内容。
- 可用性。
  - 对手无法阻止客户端访问他们的文件。

本文重点：完整性。
- 动机使用案例：多个开发人员项目的源代码。
- 如果服务器可以在源代码中插入后门，对客户端隐藏安全修复等，就很糟糕。
- 严重问题。
  - 论文提到2003年Debian服务器被攻破。
  - 2011年SourceForge被攻破。
    - [http://sourceforge.net/blog/sourceforge-attack-full-report]
  - 2019年Canonical（Ubuntu）被攻破。
    - [https://hub.packtpub.com/canonical-the-company-behind-the-ubuntu-linux-distribution-was-hacked-ubuntu-source-code-unaffected/]

示例场景：开发团队在Zoobar网络应用上工作。
- 源代码存储在共享网络文件系统中。
- 用户A编辑auth.py以使用MIT证书对用户进行身份验证。
- 用户B编辑bank.py以便用户转移真实的Techcash资金。
  - 合理的，因为用户现在使用MIT证书进行身份验证。
- 用户C打包源代码并部署。

- 明显的不希望结果：对手向用户C提供任意代码。
- 微妙的不希望结果：bank.py更改而没有auth.py更改！

朴素设计：签名文件内容。
- 使用现有网络文件系统（比如Dropbox）作为起点。
- 不期望从中获得任何安全保证。
- 每个文件包含数据，Sig(SK_writer, data)。
- 当用户写入文件时，客户端使用用户的密钥签名。
- 当用户读取文件时，客户端检查签名。
  - 假设客户端知道所有用户的公钥。
- 类似我们可能基于上一堂关于消息传递的讲座所做的事情。

在这个朴素设计中，恶意服务器能做什么？
- 不能向用户C发送任意源代码。
- 可以发送一个文件的数据而不是另一个文件的数据。
  - 可能的修复：在签名中包含文件名。
- 可以发送所有文件的旧内容。
- 可以选择性地发送任何文件的任何版本。
- 可以声称文件不存在。
- 对我们的Zoobar场景不好：
  - 对手可能导致C部署没有auth.py更改的bank.py。

文件系统需要更复杂的设计。
- 文件的一致版本：bank.py更改需要auth.py更改。
- 文件的最新版本：不应该缺少任何更改。
- 目录内容的完整性：不应该缺少任何文件。
- 权限：用户可能没有修改每个文件的权限。

SUNDR的大思想：操作日志。
- 文件系统状态由用户的操作日志决定。
- 服务器负责存储这个日志。
- 客户端解释日志。
- 简化了对复杂文件系统状态完整性的思考！

稻草人设计：论文第3.1节。
- 日志条目：获取或修改，用户，签名。
  - 签名覆盖到该点为止的整个日志。
- 客户端步骤：
  - 下载日志（其他客户端现在等待）。
  - 检查日志：
    - 每个条目中的正确签名，覆盖日志前缀。
    - 这个客户端的最后一个日志条目存在。
  - 基于日志操作构建FS状态。
  - 附加其操作并签名新日志。
  - 上传日志（其他客户端现在可以继续）。
- 低效但推理简单。
- 示例场景：
  - A: mod(auth.py), sig
  - B: mod(bank.py), sig
  - C: fetch(auth.py), sig
  - C: fetch(bank.py), sig

签名覆盖日志中所有先前操作至关重要。
- 防止对手只挑选bank.py更改。
- 如果对手从日志中删除auth.py更改，B的签名不会验证。

对手可以签名假日志条目吗？
- 客户端如何知道授权用户的公钥？
  1. 文件系统存储每个文件/目录所有者的公钥。
  2. 创建文件/目录时必须指定所有者。
  3. 所有客户端必须知道根目录所有者的公钥。
- 巧妙设计：文件系统完整性确保公钥完整性。
- 如果日志中有任何mod()未授权，客户端将拒绝日志。
  - 即mod(f)必须由f的所有者签名。

如果C没有记录其获取会发生什么？
- 恶意服务器可以提供日志的陈旧视图。
- 当C获取auth.py时，服务器给出mod(auth.py)之前的日志。
- 当C获取bank.py时，服务器给出包含mod(auth.py)和mod(bank.py)的日志。
- 实际上，服务器假装C与A + B发生了竞争。
- 结果：C使用第一次获取的auth.py和使用第二次获取的bank.py
  - 糟糕；这正是我们试图防止的。

- 有了日志中的获取，当C获取bank.py时，它对auth.py的获取必须在日志中，客户端可以检测到攻击。
  - 服务器不能假装读取auth.py与修改auth.py和bank.py同时发生。

记录获取如何帮助？
- 服务器仍然可以告诉C没有修改发生！
- 但那时C基于该日志前缀记录其获取。
- 现在服务器不能发送mod(auth.py), mod(bank.py)。
- "分叉"攻击。

很难比分叉一致性做得更好。
- 第3.2节。
- 服务器假装有N个宇宙。
- 每个客户端只看到自己的宇宙。
- 没有带外帮助无法检测这种分叉攻击的方法。
- 但分叉一致性是一个强有力的保证：服务器永远不能合并分叉。

分叉一致性相当好。
- 每个分叉内的一致视图。
- 留下强烈的攻击痕迹：不可能掩盖分叉。
- 很可能被检测到。

通过带外通信检测分叉。
- 客户端A和B比较他们对彼此最新日志条目的视图。
- 不是分叉：A的视图比B的视图新。
  - 当A和B比较他们的视图时，其他更改正在发生。
  - A在B查看日志之后查看了日志。
- 分叉：两个视图都不在另一个视图的前缀中。

"时间戳盒"。
- 指定用户负责每5秒更新某个文件。
- 如果客户端看到这些更新，它与时间戳盒在相同的"分叉"中。
- 传递性：看到这些更新的所有客户端彼此一致。
- 如果客户端看不到更新怎么办？
  - 选项1：时间戳盒可能没有发出任何更新。
    - 时间戳计算机可能损坏或断开连接。
    - 恶意服务器可能忽略来自时间戳盒的数据包。
  - 选项2：分叉攻击，客户端与时间戳盒在不同的分叉中。

稻草人不实用：日志不断增长。
- 必须检查日志中的所有签名。
- 解释日志变慢。

洞察1：只需要检查每个用户的最后一个签名。
- 当X签名其最新日志条目时，它必须已经验证了日志。
- 日志包含X的先前日志条目。
- 因此用户X的早期签名已经被X检查过。

洞察2：每个用户签名其FS状态部分的快照。
- 按文件/目录所有者分区文件系统状态。
- 当用户X进行更改时，用户签名生成的FS状态。
- 足够检查X的最新签名（参见洞察1）。
  - 不需要检查所有先前操作的签名。
- 快照包含X无论如何都可以修改的文件/目录。
  - 如果X构成任意FS状态快照没有问题。

图2：按所有者的FS快照的数据结构。
- 每个文件/目录由<所有者, i#>命名。
  - 目录将名称映射到<所有者, i#>。
  - 实际上只是基于所有者分区所有文件。
- 所有者维护将i#映射到inode状态的i表。
- 哈希使这个表紧凑。
  - Inode包含数据块的哈希。
  - i表包含每个inode的哈希。
  - i-handle是i表的哈希。
  - 哈希确保完整性：修改数据/inode会改变哈希。

如何用i表维护分叉一致性？
- 风险：恶意服务器能否提供旧i表？
- 需要确保我们有一致的i-handle集合。

思想：签名版本向量。
- 版本向量：用户 -> 用户执行的操作次数。
- 版本结构：签名i-handle与版本向量一起。

Zoobar示例：
- A mod(auth.py)：
  - 签名新的VS
    - A的i-handle包含新的auth.py
    - 版本向量：{A: 1, B: 0}
- B mod(bank.py)：
  - 向服务器询问每个用户的最新VS
  - 签名新的VS
    - B的i-handle包含新的bank.py
    - 版本向量：{A: 1, B: 1}
    - 包括A的递增计数！

如果服务器对C隐藏auth.py会发生什么？
- B的VS引用A版本1，但没有来自A的具有该版本的VS！
- 分叉攻击。

如果服务器对B隐藏auth.py会发生什么？
- B的VS将引用A版本0。
- 如果C看到来自A和B的VS，将检测到分叉攻击。
- 版本向量不是严格有序的。

剩余问题：并发。
- 不能在一个客户端附加到日志时停止世界。
- 但允许并发更改导致版本向量冲突。
- 与服务器执行分叉攻击无法区分。
- 完整SUNDR协议：更新证书。详见论文。

总结。
- 困难问题：尽管服务器被攻破仍保持完整性。
- 思考操作日志简化了问题。
- 分叉一致性。
- 优化：哈希、按所有者/写入者分区、版本向量。