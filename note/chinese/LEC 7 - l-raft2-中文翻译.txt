6.824 2021 第7讲：Raft (2)

*** 主题：Raft日志（实验2B）

只要领导人保持运行：
  客户端只与领导人交互
  客户端看不到追随者状态或日志

当更换领导人时事情变得有趣
  例如，在旧领导人失败后
  如何在没有异常的情况下更换领导人？
    分歧的副本、丢失的操作、重复的操作等

我们想要确保什么？
  如果任何服务器执行了给定日志条目中的命令，
    那么没有服务器为该日志条目执行其他操作
  （图3的状态机安全性）
  为什么？如果服务器对操作有分歧，那么
    领导人变更可能会改变客户端可见状态，
    这违反了我们模仿单个服务器的目标。
  例子：
    S1: put(k1,v1) | put(k1,v2)
    S2: put(k1,v1) | put(k2,x)
    不能允许两者都执行它们的第二个日志条目！

崩溃后日志如何会有分歧？
  领导人在向所有服务器发送最后AppendEntries之前崩溃
    S1: 3
    S2: 3 3
    S3: 3 3
  更糟：日志可能在相同条目中有不同的命令！
    在一系列领导人崩溃后，例如
        10 11 12 13  <- 日志条目号
    S1:  3
    S2:  3  3  4
    S3:  3  3  5

Raft通过让追随者采用新领导人的日志来强制达成一致
  例子：
  S3被选为任期6的新领导人
  S3发送带有条目13的AppendEntries
     prevLogIndex=12
     prevLogTerm=5
  S2回复false（AppendEntries步骤2）
  S3将nextIndex[S2]减少到12
  S3发送带有条目12+13的AppendEntries，prevLogIndex=11，prevLogTerm=3
  S2删除它的条目12（AppendEntries步骤3）
  对于S1类似的情况，但S3必须多备份一个

回滚的结果：
  每个存活的追随者删除与领导人不同的日志尾部
  然后每个存活的追随者接受该点之后的领导人条目
  现在追随者的日志与领导人的日志相同

问：为什么忘记S2的index=12 term=4条目是可以的？

新领导人可以回滚上一任期末尾的*提交*条目吗？
  即，提交的条目可能在新领导人日志中缺失吗？
  这将是一场灾难——旧领导人可能已经向客户端说了"是"
  所以：Raft需要确保选举的领导人拥有所有提交的日志条目

为什么不选择具有最长日志的服务器作为领导人？
  例子：
    S1: 5 6 7
    S2: 5 8
    S3: 5 8
  首先，这种情况可能发生吗？如何发生的？
    S1在任期6是领导人；崩溃+重启；任期7的领导人；崩溃并保持下线
      两次都是在只追加到自己的日志后崩溃
    问：在S1在任期7崩溃后，为什么S2/S3不选择6作为下一任期？
    下一任期将是8，因为S2/S3中至少有一个在投票时了解了7
    S2在任期8是领导人，只有S2+S3存活，然后崩溃
  所有对等方重启
  谁应该是下一领导人？
    S1有最长日志，但条目8可能已经提交了！！！
    所以新领导人只能是S2或S3之一
    即规则不能简单地是"最长日志"

5.4.1末尾解释了"选举限制"
  RequestVote处理程序只为"至少最新"的候选人投票：
    候选人在最后日志条目中有更高任期，或
    候选人有相同的最后任期和相同长度或更长的日志
  所以：
    S2和S3不会投票给S1
    S2和S3会互相投票
  所以只有S2或S3可以是领导人，将迫使S1丢弃6,7
    好的，因为6,7不在多数中 -> 没有提交 -> 从不发送回复给客户端
    -> 客户端将重新发送丢弃的命令

要点：
  "至少最新"规则确保新领导人的日志包含
    所有可能提交的条目
  所以新领导人不会回滚任何已提交的操作

问题（来自上一讲）
  图7，顶部服务器死了；哪个可以被选举？

根据图7中谁被选举为领导人，不同的条目
  最终会被提交或丢弃
  有些将始终保持提交：111445566
    它们*可能*已经提交+执行+回复了
  有些肯定会被丢弃：f的2和3；e的最后4,4
  c的6,6和d的7,7可能被丢弃或提交

谁可以在图7中成为领导人？（顶部服务器死了）
  需要4票成为领导人
  肯定不是：b, e, f
    b：没人会投票给它
      e有相同的最后任期，但它的日志更长
    f：每个其他服务器在最后日志条目中有更高任期
      没人会投票给它
    e：只有b可以投票给它
  肯定是：d
    每个服务器都会投票给它
    （如果某个服务器在任期9，它可能会投票反对）
  可能是a和c
    c：如果d下线，肯定
    a：如果c和d都肯定下线
      b, e和f会跟随
  如果c和d在线时a开始选举怎么办？
    取决于当前任期是什么（图中未显示）
      - a可能以至少与c/d一样大的任期开始，并赢得
        选举
      - a可能被c和d投票否决（如果其中一个有更高当前任期）
    a向c和d发送AppendEntries RPC：
      它们跟随（a的任期>=它们的）
      没有提交的条目被删除，所以好的

如何快速回滚
  图2设计每次RPC备份一个条目——慢！
  实验测试者可能需要更快的回滚
  论文在5.3节末尾概述了一个方案
    没有细节；这是我的猜测；可能有更好的方案
      情况1      情况2       情况3
  S1: 4 5 5       4 4 4        4
  S2: 4 6 6 6 或  4 6 6 6  或  4 6 6 6
  S2是任期6的领导人，S1恢复生命，S2为最后一个6发送AE
    AE有prevLogTerm=6
  来自S1的拒绝包括：
    XTerm：冲突条目中的任期（如果有）
    XIndex：该任期第一个条目的索引（如果有）
    XLen：日志长度
  情况1（领导人没有XTerm）：
    nextIndex = XIndex
  情况2（领导人有XTerm）：
    nextIndex = 领导人的XTerm最后一个条目
  情况3（追随者日志太短）：
    nextIndex = XLen

*** 主题：持久化（实验2C）

我们希望在服务器崩溃后发生什么？
  Raft可以在缺少一个服务器的情况下继续
    但故障服务器必须尽快修复以避免降至多数以下
  两种策略：
  * 用新的（空）服务器替换
    需要将整个日志（或快照）传输到新服务器（慢）
    我们*必须*支持这个，以防故障是永久的
  * 或重启崩溃的服务器，保持状态完整重新加入，赶上
    需要在崩溃间持久的状态
    我们*必须*支持这个，为了同时电源故障
  让我们谈谈第二种策略——持久化

如果服务器崩溃并重启，Raft必须记住什么？
  图2列出了"持久状态"：
    log[], currentTerm, votedFor
  只有在这些完整时，Raft服务器才能在重启后重新加入
  因此它必须将它们保存到非易失性存储
    非易失性 = 磁盘、SSD、电池备份RAM等
    在每次更改后保存——代码中的许多点
    或在发送任何RPC或RPC回复之前
  为什么log[]？
    如果服务器在提交条目的领导人多数中，
      必须在重启后记住条目，所以任何未来领导人都
      被保证看到提交的日志条目
  为什么votedFor？
    为了防止客户端投票给一个候选人，然后重启，
      然后在相同（或更老！）任期投票给不同的候选人
    可能导致同一任期有两个领导人
  为什么currentTerm？
    为了确保任期只增加，所以每个任期最多有一个领导人
    为了检测来自陈旧领导人和候选人的RPC

一些Raft状态是易失性的
  commitIndex, lastApplied, next/matchIndex[]
  为什么不保存这些是可以的？

持久化通常是性能的瓶颈
  硬盘写入需要10毫秒，SSD写入需要0.1毫秒
  所以持久化限制我们每秒100到10000次操作
  （另一个潜在瓶颈是RPC，在局域网上需要<< 1毫秒）
  许多技巧来应对持久化的缓慢：
    每次磁盘写入批量处理许多新日志条目
    持久化到电池备份RAM，而不是磁盘

服务（例如k/v服务器）如何在崩溃+重启后恢复其状态？
  简单方法：从空状态开始，重放Raft的整个持久日志
    lastApplied是易失性的并从零开始，所以你可能不需要额外代码！
    这就是图2所做的
  但重放对于长期运行系统来说太慢
  更快：使用Raft快照并只重放日志尾部

*** 主题：日志压缩和快照（实验2D）

问题：
  日志会变得巨大——比状态机状态大得多！
  在重启时重放或发送到新服务器需要很长时间

幸运的是：
  服务器不需要*既*有完整日志*又*有服务状态
    日志的执行部分被捕获在状态中
    客户端只看到状态，不是日志
  服务状态通常小得多，所以我们只保留那个

服务器*不能*丢弃哪些条目？
  未执行的条目——尚未反映在状态中
  未提交的条目——可能是领导人多数的一部分

解决方案：服务定期创建持久"快照"
  [图：服务状态、磁盘上的快照、raft日志（内存和磁盘中相同）]
  特定日志条目执行时的服务状态副本
    例如k/v表
  服务将快照写入持久存储（磁盘）
    快照包括最后包含的日志条目的索引
  服务告诉Raft它通过某个日志索引快照了
  Raft丢弃该索引之前的日志
  服务器可以随时创建快照并丢弃日志前缀
    例如当日志变得太长时

崩溃+重启时会发生什么？
  服务从磁盘读取快照
  Raft从磁盘读取持久日志
  服务告诉Raft将lastApplied设置为最后包含的索引
    以避免重新应用已应用的日志条目

问题：如果追随者的日志在领导人的日志开始之前结束怎么办？
  因为追随者离线，领导人丢弃了日志的早期部分
  nextIndex[i]将备份到领导人日志的开始
  所以领导人无法用AppendEntries RPC修复那个追随者
  因此需要InstallSnapshot RPC

哲学笔记：
  状态通常等同于操作历史
  你通常可以选择存储或通信哪一个
  我们将在课程后面看到这种对偶性的例子

实用笔记：
  如果状态小，Raft的快照方案是合理的
  对于大型数据库，例如如果复制千兆字节数据，不太好
    创建和写入磁盘慢
  也许服务数据应该在磁盘上的B树中
    不需要显式快照，因为已经在磁盘上
  但是处理滞后副本很难
    领导人应该保存日志一段时间
    或记住状态哪些部分已被更新

*** 线性化

我们需要为实验3等定义"正确"
  客户端应该期望Put和Get如何表现？
  通常称为一致性合约
  帮助我们推理如何正确处理复杂情况
    例如并发性、副本、故障、RPC重传、
         领导人变更、优化
  我们将在6.824中看到许多一致性定义

"线性化"是最常见和直观的定义
  形式化对单个服务器的期望行为（"强"一致性）

线性化定义：
  执行历史是线性化的，如果
    可以找到所有操作的全序，
    匹配实时（对于非重叠操作），并且
    其中每个读取看到来自
    顺序中前面写入的值。

历史是客户端操作的记录，每个都有
  参数、返回值、开始时间、完成时间

历史例子1：
  |-Wx1-| |-Wx2-|
    |---Rx2---|
      |-Rx1-|
"Wx1"意思是"向记录x写入值1"
"Rx1"意思是"读取记录x产生值1"
绘制约束箭头：
  顺序遵守值约束（W -> R）
  顺序遵守实时约束（Wx1 -> Wx2）
这个顺序满足约束：
  Wx1 Rx1 Wx2 Rx2
  所以历史是线性化的

注意：定义基于外部行为
  所以我们可以在不知道服务如何工作的情况下应用它
注意：历史明确包含并发性，形式为
  重叠操作（操作不在时间点发生），因此很好地
  匹配分布式系统的操作方式。

历史例子2：
  |-Wx1-| |-Wx2-|
    |--Rx2--|
              |-Rx1-|
绘制约束箭头：
  Wx1在Wx2之前（时间）
  Wx2在Rx2之前（值）
  Rx2在Rx1之前（时间）
  Rx1在Wx2之前（值）
有一个循环——所以不能变成线性顺序。所以这个
历史不是线性化的。（即使Rx1与Wx2重叠，
没有Rx2也会是线性化的。）

历史例子3：
|--Wx0--|  |--Wx1--|
            |--Wx2--|
        |-Rx2-| |-Rx1-|
顺序：Wx0 Wx2 Rx2 Wx1 Rx1
所以历史是线性化的。
所以：
  服务可以为并发写入选择任一顺序。
  例如Raft将并发操作放入日志。

历史例子4：
|--Wx0--|  |--Wx1--|
            |--Wx2--|
C1:     |-Rx2-| |-Rx1-|
C2:     |-Rx1-| |-Rx2-|
约束是什么？
  Wx2然后C1:Rx2（值）
  C1:Rx2然后Wx1（值）
  Wx1然后C2:Rx1（值）
  C2:Rx1然后Wx2（值）
  有一个循环！所以不是线性化的。
所以：
  服务可以为并发写入选择任一顺序
  但所有客户端必须以相同顺序看到写入
  当我们有副本或缓存时这很重要
    它们必须都同意操作发生的顺序

历史例子5：
|-Wx1-|
        |-Wx2-|
                |-Rx1-|
约束：
  Wx2在Rx1之前（时间）
  Rx1在Wx2之前（值）
  （或：时间约束意味着唯一可能的顺序是Wx1 Wx2 Rx1）
有一个循环；不是线性化的
所以：
  读取必须返回新数据：陈旧值不是线性化的
  即使读取者不知道写入
    时间规则要求读取产生最新数据
  线性化禁止许多情况：
    脑裂（两个活跃领导人）
    重启后忘记提交的写入
    从滞后副本读取

历史例子6：
假设客户端如果没有得到回复就重新发送请求
如果是回复丢失的情况：
  领导人记得它已经看到的客户端请求
  如果看到重复，用第一次执行的保存回复回复
但这可能产生很久以前保存的值——陈旧值！
线性化说什么？
C1: |-Wx3-|          |-Wx4-|
C2:          |-Rx3-------------|
顺序：Wx3 Rx3 Wx4
所以：返回旧的保存值3是正确的

你可能觉得这个页面有用：
https://www.anishathalye.com/2017/06/04/testing-distributed-systems-for-linearizability/

*** 重复RPC检测（实验3）

如果Put或Get RPC超时，客户端应该做什么？
  即Call()返回false
  如果服务器死了，或请求丢失：重新发送
  如果服务器执行了，但请求丢失：重新发送是危险的

问题：
  这两种情况对客户端来说看起来相同（没有回复）
  如果已经执行，客户端仍需要结果

想法：重复RPC检测
  让k/v服务检测重复的客户端请求
  客户端为每个请求选择ID，在RPC中发送
    相同RPC的重新发送中相同ID
  k/v服务维护按ID索引的表
  为每个RPC创建条目
    执行后记录值
  如果具有相同ID的第2个RPC到达，它是重复的
    从表中的值生成回复

设计谜题：
  什么时候（如果有的话）我们可以删除表条目？
  如果新领导人接管，它如何获得重复表？
  如果服务器崩溃，它如何恢复它的表？

保持重复表小的想法
  每个客户端一个表条目，而不是每个RPC一个
  每个客户端一次只有一个未完成的RPC
  每个客户端按顺序编号RPC
  当服务器接收到客户端RPC #10时，
    它可以忘记客户端的低条目
    因为这意味着客户端永远不会重新发送更旧的RPC

一些细节：
  每个客户端需要唯一的客户端ID——也许是64位随机数
  客户端在每个RPC中发送客户端ID和序列号
    如果重新发送则重复序列号
  k/v服务中按客户端ID索引的重复表
    只包含序列号，如果已经执行则包含值
  RPC处理程序首先检查表，只有在序列号>表条目时才Start()
  每个日志条目必须包含客户端ID、序列号
  当操作出现在applyCh上
    更新客户端表条目中的序列号和值
    唤醒等待的RPC处理程序（如果有）

如果重复请求在原始执行之前到达怎么办？
  可以调用Start()（再次）
  它可能出现在日志中两次（相同的客户端ID，相同的序列号）
  当cmd出现在applyCh上时，如果表说已经见过就不执行

新领导人如何获得重复表？
  所有副本应该在执行时更新它们的重复表
  所以如果它们成为领导人信息已经存在

如果服务器崩溃它如何恢复它的表？
  如果没有快照，日志重放将填充表
  如果有快照，快照必须包含表的副本

但是等等！
  k/v服务器现在从重复表返回旧值
  如果表中的回复值是陈旧的怎么办？
  那可以吗？

例子：
  C1           C2
  --           --
  put(x,10)
               get(x)的第一次发送，10回复丢失
  put(x,20)
               重新发送get(x)，从表得到10，不是20

线性化说什么？
C1: |-Wx10-|          |-Wx20-|
C2:          |-Rx10-------------|
顺序：Wx10 Rx10 Wx20
所以：返回记住的值10是正确的

*** 只读操作（第8节末尾）

问：Raft领导人必须在回复之前在日志中提交只读操作吗？
   例如Get(key)？

即，领导人可以使用其键/值表的当前内容立即响应Get()吗？

答：不，图2或实验中的方案不行。
   假设S1认为它是领导人，并接收到Get(k)。
   它可能最近输掉了选举，但没有意识到，
   由于丢失的网络数据包。
   新的领导人，比如S2，可能已经处理了该键的Put()，
   所以S1键/值表中的值是陈旧的。
   提供陈旧数据不是线性化的；这是脑裂。

所以：图2要求Get()被提交到日志中。
    如果领导人能够提交Get()，那么（在
    日志中的那一点）它仍然是领导人。在S1
    的情况下，上面不知情地失去了领导权，它不会
    能够获得提交Get()所需的
    多数肯定AppendEntries回复，
    所以它不会回复客户端。

但是：许多应用程序是重读的。提交Get()
  需要时间。有什么方法可以避免提交
  只读操作吗？这是实际系统中的
  巨大考虑。

想法：租约
  按如下方式修改Raft协议
  定义一个租约期，例如5秒
  每次领导人获得AppendEntries多数后，
    它有权在租约期内响应只读请求
    而不将只读请求提交
    到日志，即不发送AppendEntries。
  新领导人不能执行Put()直到前一租约期
    已过期
  所以追随者跟踪它们响应的最后一次时间
    到AppendEntries，并告诉新领导人（在
    RequestVote回复中）。
  结果：更快的只读操作，仍然是线性化的。

注意：对于实验，你应该将Get()提交到日志中；
      不要实现租约。

在实践中，人们经常（但不总是）愿意容忍陈旧
  数据以换取更高性能