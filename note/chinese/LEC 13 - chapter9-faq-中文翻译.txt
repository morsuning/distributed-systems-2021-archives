分布式事务常见问题解答

问：这些内容如何融入6.824课程？

答：当数据分布在多台计算机上时，单个操作通常需要读取和/或修改多台计算机上的数据。这种多步操作如何与对相同数据的并发操作交互，以及如果在这种操作中间发生崩溃会发生什么，通常是系统健壮性和编程便利性的关键问题。良好行为的黄金标准是事务，通常通过两阶段提交、两阶段锁定和日志记录来实现。今天的6.033教材阅读解释了这些思想。稍后我们将查看提供类似强语义的系统，以及为了更高性能而放松一致性的系统。

问：为什么事务的原子性如此重要？

答："事务"的含义是事务内部的步骤相对于故障和其他事务原子地发生。这里的原子性意味着"要么全部要么全不"。事务是一些存储系统提供的功能，以使编程更容易。事务有用的情况示例是银行转账。如果银行想从Alice的账户转账100美元到Bob的账户，如果在转账过程中崩溃导致Alice被扣款100美元但Bob*没有*收到100美元，那将非常尴尬。因此（如果你的存储系统支持事务）程序员可以编写如下代码：

BEGIN TRANSACTION
  decrease Alice's balance by 100;
  increase Bob's balance by 100;
END TRANSACTION

事务系统将确保事务是原子的；要么两个操作都发生，要么都不发生，即使某处发生故障。

问：能否使用Raft而不是两阶段提交？

答：两阶段提交和Raft解决不同的问题。

两阶段提交导致不同的计算机执行*不同*的操作（例如，Alice的银行扣减Alice的账户，Bob的银行增加Bob的账户），并使它们*全部*执行它们的操作，或都不执行。两阶段提交系统在面临故障时通常不可用（无法取得进展），因为它们必须等待所有参与计算机执行它们的事务部分。

Raft导致大多数对等点都执行*相同*的操作（因此它们保持副本）。Raft只等待多数是可以的，因为对等点是副本，因此我们可以在面对故障时使系统可用。

问：两阶段锁定和两阶段提交有什么区别？

答：它们基本无关；只是它们的名称中都有"两阶段"。

2PL是一种为事务中的记录获取锁的方案；它在非分布式环境和分布式环境中都有用。

2PC是一种在多台机器上执行事务的方案，其中每台机器拥有事务中使用的一些记录。

问：在两阶段提交中，为什么工作进程会发送中止消息而不是PREPARED消息？

答：我们最关心的原因是如果参与者在为事务完成了一些工作但在收到准备消息之前崩溃并重启；在崩溃期间，它将丢失其进行的临时更新记录和获取的锁，因此无法完成事务。另一种可能性（取决于数据库的工作方式）是如果工作进程检测到数据违反约束（例如，事务试图在需要唯一键的表中写入具有重复键的记录）。另一种可能性是工作进程涉及死锁，必须中止以打破死锁。

问：两阶段锁定会产生死锁吗？

答：是的。如果两个事务都使用记录R1和R2，但顺序相反，它们将各自获得一个锁，然后试图获取另一个锁时死锁。数据库能够检测这些死锁并打破它们。数据库可以通过锁定获取超时或通过在事务之间的等待图中找到循环来检测死锁。可以通过中止其中一个参与事务来打破死锁。

问：为什么锁是保持到事务提交或中止之后很重要？

答：如果事务在提交之前释放锁，由于中止或崩溃，可能很难避免某些不可序列化的执行。在这个例子中，假设T1在更新x后但在提交之前释放了x的锁：

  T1:           T2:
  x = x + 1
                y = x
                commit

  commit

y最终大于x是不合法的。但如果T1释放了x的锁，然后T2获取锁，写入y，并提交，但后来T1中止或系统崩溃且无法完成T1，我们将最终得到y大于x的情况。

为了避免必须处理上述情况，人们使用2PL的"严格强"变体，它只在提交或中止后才释放锁。

问：两阶段锁定规则中，说事务在第一次释放锁后不允许再获取任何锁，这一点有什么意义？

答：前一个问题/答案概述了一个答案。

另一个答案是，即使没有故障或中止，在释放后获取也会导致不可序列化的执行。

  T1:         T2:
  x = x + 1
              z = x + y
  y = y + 1

假设x和y开始时都为零，两个事务都执行并成功提交。序列化允许的z的唯一最终值是0和2（分别对应顺序T2;T1和T1;T2）。但如果T1在获取y的锁和修改y之前释放了x的锁，T2可能在T1的两个语句之间完全执行并提交，使z值为1，这是不合法的。如果T1在使用y时保持x的锁，正如两阶段锁定要求的那样，就可以避免这个问题。

问：两阶段提交是否解决了阅读材料第9.6.4节中描述的两将军困境？

答：如果没有故障，没有消息丢失，所有消息都快速传递，两阶段提交可以解决这个困境。如果事务协调器（TC）说"提交"，两个将军在指定时间攻击；如果TC说"中止"，都不攻击。

在现实世界中，消息可能丢失和延迟，TC可能崩溃并且一段时间不重启。那么我们可能会遇到将军G1从TC听到"提交"，而将军G2什么都没听到的情况。当攻击的指定时间到达时，它们可能处于这种状态。此时G1和G2应该怎么做？我想不出一套将军可以遵循的规则，能够在各种情况下产生可接受的结果。

这套规则不起作用，因为它导致只有一个将军攻击：

  * if you heard "commit" from the TC, do attack.
  * if you heard "abort" from the TC, don't attack.
  * if you heard nothing from the TC, don't attack.

我们也不能这样，因为如果G1听到"中止"而G2什么都没听到，我们会再次只有一个将军攻击：

  * if you heard "commit" from the TC, do attack.
  * if you heard "abort" from the TC, don't attack.
  * if you heard nothing from the TC, do attack.     [注意这里的"do"]

这是安全的，但导致将军无论什么情况都不攻击：

  * if you heard "commit" from the TC, don't attack.
  * if you heard "abort" from the TC, don't attack.
  * if you heard nothing from the TC, don't attack.

困境的真正困难在于有一个硬性截止时间，两个将军（或都不）必须同时攻击。如果没有截止时间，并且参与者（工作进程）可以在不同时间提交，那么两阶段提交是有用的。

问：这些锁是排他的，还是可以允许多个读者同时访问？

答：默认情况下，6.824中的"锁"指的是排他锁。但有些数据库可以允许多个读者或单个写者获得对记录的锁定访问。当事务读取记录然后写入它时必须小心，因为锁最初将是读锁，然后必须升级为写锁。在某些情况下死锁的机会也增加了；如果两个事务同时想要增加同一个记录，它们在将该记录的读锁升级为写锁时可能会死锁，而如果锁总是排他的，它们不会死锁。

问：应该如何在悲观和乐观并发控制之间决定？

答：如果你事务冲突很多（使用相同的记录，并且一个或多个事务写入），那么锁定更好。锁定导致事务等待，而当有冲突时，大多数OCC系统会中止其中一个事务；中止（实际上是随后的重试）是昂贵的。

如果你的事务很少冲突，那么OCC比锁定更可取。OCC不花费CPU时间获取/释放锁，并且（如果冲突很少）OCC很少中止。OCC系统的"验证"阶段通常使用锁，但它们通常比悲观设计中的锁保持更短的时间。

问：如果事务协调器崩溃，两阶段提交工作进程应该怎么做？

答：如果工作进程已经告诉协调器它准备提交，那么工作进程后来不能改变主意。原因是协调器可能（在崩溃之前）已经告诉其他工作进程提交。所以工作进程必须等待（保持锁）协调器重启并重新发送它的决定。

无限期等待并保持锁是一个真正的问题，因为锁会迫使越来越多的其他事务也被阻塞。所以人们倾向于避免两阶段提交，或者他们试图使协调器可靠。例如，Google的Spanner使用Paxos复制协调器（和所有其他服务器）。

问：人们为什么不使用三阶段提交，它允许工作进程在协调器崩溃时提交或中止？

答：三阶段提交只有在网络可靠的情况下，或者工作进程能够可靠地区分协调器死亡和网络不传递数据包的情况下才有效。例如，如果存在网络分区，三阶段提交将无法正确工作。在大多数实际网络中，分区是可能的。

问：可以有多个事务活动吗？参与者如何知道消息指的是哪个事务？

答：可以有许多并发事务，由多个TC管理。TC为每个事务分配唯一的事务ID（TID）。每条消息包括相关事务的TID。TC和参与者用TID标记它们表中的条目，以便（例如）当COMMIT消息到达参与者时，它知道要使哪些临时记录永久化，以及要释放哪些锁。

问：如果事务必须中止，两阶段提交系统如何撤销修改？

答：每个参与者对记录的临时副本执行修改。如果参与者对TC的准备消息回答"是"，参与者必须首先将临时记录值保存到其磁盘上的日志中，这样如果它崩溃并重启就能找到它们。如果TC决定提交，参与者必须将临时值复制到真实的数据库记录；如果TC决定中止，参与者必须丢弃临时记录。

问：序列化如何与线性化相关？

答：它们是相似的概念，来自不同的社区。两者都要求最终结果与某个串行执行相同。序列化通常指的是整个事务，每个都涉及多个操作。线性化通常指的是简单的读写。还有一种情况是，线性化要求等价的串行执行与实际执行的实际时间顺序匹配，而序列化通常不要求。

问：为什么日志在我们查看的设计中如此频繁出现？

答：一个原因是日志捕获了系统为事务选择的串行顺序，以便例如所有副本以相同顺序执行事务，或者服务器在崩溃+重启后以与崩溃前相同的顺序考虑事务。

另一个原因是日志是将数据写入硬盘或SSD的有效方式，因为这两种介质在顺序写入（即追加到日志）方面都比随机写入快得多。

第三个原因是日志是崩溃恢复软件查看系统在崩溃前进展程度以及最后事务是否在日志中有完整记录从而可以安全重放的方便方式。也就是说，日志是通过预写日志实现可崩溃恢复原子事务的方便方式。

问：除了日志之外，还有其他结构也能很好地工作吗？

答：没有像日志这样通用的东西。

你可以通过其他方式存储数据（例如b树）并在数据中存储序列号来记录顺序（Frangipani对元数据这样做，除了使用日志）。

如果你使用的持久存储系统在随机更新方面和顺序更新一样快，例如电池备份RAM，你就不必担心性能问题。然而，此类系统通常比硬盘或SSD更昂贵且不那么健壮。

对于预写属性，你可以为每个数据记录存储一个迷你日志。但是，崩溃恢复软件找到不完整迷你日志的完整集合可能会很耗时。

获得可崩溃恢复原子操作的另一种方式是在新存储中准备一个完整的新数据结构，然后使用单个提交写入来替换原始数据结构。这对于树形数据结构最有意义。NetApp WAFL文件系统使用这个想法：

https://atg.netapp.com/wp-content/uploads/2000/01/file-system-design.pdf

这种安排可能使支持并发事务变得困难。

问：什么是锁管理器？

答：实现acquire()和release()的软件模块。它还可以通过在使用acquire()获取锁时构造等待图来实现死锁检测。在某些情况下，该模块是在机器上运行的独立服务（例如，Franginpani中的锁服务）。