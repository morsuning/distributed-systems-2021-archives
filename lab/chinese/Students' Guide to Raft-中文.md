在过去的几个月里，我一直是 MIT [6.824 分布式系统](https://pdos.csail.mit.edu/6.824/) 课程的教学助理。该课程传统上有一系列基于 Paxos 共识算法的实验，但今年，我们决定转向 [Raft](https://raft.github.io/)。Raft 被"设计为易于理解"，我们希望这一改变可能使学生的生活更轻松。

这篇文章以及配套的[Raft 教师指南](https://thesquareplanet.com/blog/instructors-guide-to-raft/)文章记录了我们在 Raft 方面的旅程，希望对 Raft 协议的实现者和试图更好地理解 Raft 内部机制的学生有所帮助。如果你正在寻找 Paxos 与 Raft 的比较，或者对 Raft 的更多教学分析，你应该去阅读教师指南。本文底部包含了 6.824 学生常问的问题列表，以及这些问题的答案。如果你遇到的问题没有在本文的主要内容中列出，请查看[问答](https://thesquareplanet.com/blog/raft-qa/)。这篇文章相当长，但它提出的所有观点都是许多 6.824 学生（和教学助理）遇到的真实问题。值得一读。

# [背景](https://thesquareplanet.com/blog/students-guide-to-raft/#background)

在我们深入探讨 Raft 之前，一些背景知识可能有用。6.824 曾经有一套基于 [Paxos 的实验](http://nil.csail.mit.edu/6.824/2015/labs/lab-3.html)，这些实验是用 [Go](https://golang.org/) 构建的；选择 Go 既是因为学生容易学习，也因为它非常适合编写并发、分布式应用程序（goroutine 特别有用）。在四个实验的过程中，学生构建一个容错的、分片的键值存储。第一个实验让他们构建一个基于共识的日志库，第二个在其上添加键值存储，第三个将键空间分片到多个容错集群中，由容错的分片主节点处理配置变更。我们还有第四个实验，学生必须处理机器的故障和恢复，无论磁盘是否完好。这个实验是学生的默认最终项目。

今年，我们决定使用 Raft 重写所有这些实验。前三个实验都是相同的，但第四个实验被删除了，因为持久化和故障恢复已经内置到 Raft 中。本文将主要讨论我们在第一个实验中的经验，因为它是与 Raft 最直接相关的，虽然我也会谈到在 Raft 之上构建应用程序（如第二个实验）。

对于刚接触 Raft 的人来说，最好通过协议[网站](https://raft.github.io/)上的文本来描述它：

> Raft 是一个被设计为易于理解的共识算法。它在容错性和性能方面与 Paxos 等效。不同之处在于它被分解成相对独立的子问题，并且它清晰地解决了实用系统所需的所有主要部分。我们希望 Raft 能让共识被更广泛的受众使用，并且这个更广泛的受众能够开发出比今天可用的各种更高质量的基于共识的系统。

像[这个](http://thesecretlivesofdata.com/raft/)这样的可视化很好地概述了协议的主要组件，论文很好地解释了为什么需要各种部分。如果你还没有阅读[扩展 Raft 论文](https://raft.github.io/raft.pdf)，你应该在继续阅读本文之前去阅读它，因为我会假设你对 Raft 有相当的了解。

与所有分布式共识协议一样，魔鬼非常在于细节。在没有故障的稳定状态下，Raft 的行为容易理解，可以用直观的方式解释。例如，从可视化中很容易看出，假设没有故障，最终会选举出领导者，最终发送给领导者的所有操作都会被跟随者以正确的顺序应用。然而，当引入延迟消息、网络分区和故障服务器时，每一个 if、but 和 and 都变得至关重要。特别是，我们看到了许多错误反复出现，仅仅是由于阅读论文时的误解或疏忽。这个问题不是 Raft 独有的，它是所有提供正确性的复杂分布式系统中都会出现的问题。

Raft 的最终指南在 Raft 论文的图 2 中。这个图规定了 Raft 服务器之间交换的每个 RPC 的行为，给出了服务器必须维护的各种不变量，并规定了某些操作应该在何时发生。在本文的其余部分，我们将大量讨论图 2。它需要*逐字逐句地*遵循。

图 2 定义了每个服务器在每种状态下，对每个传入 RPC 应该做什么，以及某些其他事情应该在何时发生（例如何时可以安全地应用日志中的条目）。起初，你可能倾向于将图 2 视为一种非正式的指南；你读一遍，然后开始编写一个大致遵循它所说的实现。这样做，你会很快启动并运行一个大部分工作的 Raft 实现。然后问题就开始了。

事实上，图 2 是极其精确的，它所做的每一个陈述在规范术语上都应该被视为**必须**，而不是**应该**。例如，你可能会合理地在收到 `AppendEntries` 或 `RequestVote` RPC 时重置对等方的选举定时器，因为两者都表明某个其他对等方要么认为它是领导者，要么试图成为领导者。直观上，这意味着我们不应该干涉。然而，如果你仔细阅读图 2，它说：

> 如果选举超时结束而没有收到*来自当前领导者*的 `AppendEntries` RPC 或*授予*候选者投票：转换为候选者。

这种区别结果很重要，因为前一种实现在某些情况下可能导致活性显著降低。

## [细节的重要性](https://thesquareplanet.com/blog/students-guide-to-raft/#the-importance-of-details)

为了使讨论更具体，让我们考虑一个让许多 6.824 学生绊倒的例子。Raft 论文在许多地方提到了*心跳 RPC*。具体来说，领导者偶尔（至少每个心跳间隔一次）向所有对等方发送 `AppendEntries` RPC 以防止他们开始新的选举。如果领导者没有新条目要发送给特定对等方，`AppendEntries` RPC 不包含任何条目，并被视为心跳。

我们的许多学生假设心跳是某种"特殊的"；当对等方收到心跳时，它应该与非心跳 `AppendEntries` RPC 区别对待。特别是，许多人会在收到心跳时简单地重置他们的选举定时器，然后返回成功，而不执行图 2 中指定的任何检查。这是*极其危险的*。通过接受 RPC，跟随者隐式地告诉领导者他们的日志与领导者的日志匹配，包括并包含在 `AppendEntries` 参数中包含的 `prevLogIndex`。收到回复后，领导者可能然后（错误地）决定某个条目已经复制到多数服务器，并开始提交它。

许多人遇到的另一个问题（通常在修复上述问题后立即出现）是，在收到心跳时，他们会截断跟随者在 `prevLogIndex` 之后的日志，然后附加包含在 `AppendEntries` 参数中的任何条目。这也是不正确的。我们可以再次转向图 2：

> *如果*现有条目与新条目冲突（相同索引但不同任期），删除现有条目及其后的所有条目。

这里的*如果*至关重要。如果跟随者拥有领导者发送的所有条目，跟随者**绝不能**截断其日志。领导者发送的条目*之后*的任何元素**必须**保留。这是因为我们可能从领导者那里收到过时的 `AppendEntries` RPC，截断日志将意味着"收回"我们可能已经告诉领导者我们日志中已有的条目。

# [调试 Raft](https://thesquareplanet.com/blog/students-guide-to-raft/#debugging-raft)

不可避免地，你的 Raft 实现的第一次迭代会有错误。第二次也会。第三次也会。第四次也会。一般来说，每次都会比前一次错误更少，而且根据经验，你的大部分错误都是由于没有忠实地遵循图 2 造成的。

调试 Raft 时，通常有四个主要的错误来源：活锁、不正确或不完整的 RPC 处理程序、未能遵循规则，以及任期混淆。死锁也是一个常见问题，但通常可以通过记录所有锁定和解锁，并找出你获得了哪些锁但没有释放来调试。让我们依次考虑这些：

## [活锁](https://thesquareplanet.com/blog/students-guide-to-raft/#livelocks)

当你的系统活锁时，系统中的每个节点都在做某事，但集体而言，你的节点处于一种无法取得进展的状态。这在 Raft 中很容易发生，特别是如果你不严格遵循图 2。一种活锁场景特别常见；没有领导者被选举，或者一旦领导者被选举，某个其他节点开始选举，迫使最近选举的领导者立即退位。

这种情况出现的原因有很多，但有一些错误我们看到许多学生反复犯：

* 确保你在图 2 说你应该的时候*精确地*重置你的选举定时器。具体来说，你应该*只*在以下情况下重新启动你的选举定时器：a) 你从*当前*领导者那里收到 `AppendEntries` RPC（即，如果 `AppendEntries` 参数中的任期过时，你*不应该*重置你的定时器）；b) 你正在开始选举；或 c) 你*授予*另一个对等方投票。
  最后一种情况在不可靠网络中特别重要，在这些网络中跟随者很可能有不同的日志；在这些情况下，你经常最终只有少数服务器是多数服务器愿意投票的对象。如果每当有人请求你投票给他们时都重置选举定时器，这使得具有过时日志的服务器向前推进的可能性与具有较长日志的服务器相同。
  事实上，因为具有足够最新日志的服务器如此之少，这些服务器相当不可能能够在足够的和平中完成选举而被选举。如果你遵循图 2 的规则，具有更新日志的服务器不会被过时服务器的选举打断，因此更有可能完成选举并成为领导者。
* 遵循图 2 关于何时开始选举的指示。特别是，注意如果你是候选者（即，你当前正在运行选举），但选举定时器触发，你应该开始*另一个*选举。这对于避免系统由于延迟或丢失的 RPC 而停滞很重要。
* 确保你在处理传入 RPC 之前遵循"服务器规则"中的第二条规则。第二条规定：

  > 如果 RPC 请求或响应包含任期 `T > currentTerm`：设置 `currentTerm = T`，转换为跟随者（§5.1）

  例如，如果你已经在当前任期投票，并且传入的 `RequestVote` RPC 具有比你更高的任期，你应该*首先*退位并采用他们的任期（从而重置 `votedFor`），*然后*处理 RPC，这将导致你授予权票！

## [不正确的 RPC 处理程序](https://thesquareplanet.com/blog/students-guide-to-raft/#incorrect-rpc-handlers)

尽管图 2 明确规定了每个 RPC 处理程序应该做什么，但一些微妙之处仍然容易错过。这里有一些我们一次又一次看到的，你应该在你的实现中注意的事项：

* 如果一个步骤说"回复 false"，这意味着你应该*立即回复*，而不执行任何后续步骤。
* 如果你收到一个 `AppendEntries` RPC，其 `prevLogIndex` 指向你的日志末尾之外，你应该按照你确实有该条目但任期不匹配的情况处理（即回复 false）。
* 即使领导者没有发送任何条目，也应该执行 `AppendEntries` RPC 处理程序的检查 2。
* `AppendEntries` 最终步骤（#5）中的 `min` 是*必要的*，它需要使用最后一个*新*条目的索引来计算。仅仅让函数在你的日志中的 `lastApplied` 和 `commitIndex` 之间应用东西并在到达日志末尾时停止是*不够的*。这是因为你的日志中可能有在领导者发送给你的条目*之后*与领导者日志不同的条目（领导者发送给你的所有条目都与你的日志中的条目匹配）。因为 #3 规定你只有在有冲突条目时才截断日志，这些条目不会被移除，如果 `leaderCommit` 超过了领导者发送给你的条目，你可能会应用不正确的条目。
* 按照 5.4 节中的描述*精确地*实现"最新日志"检查很重要。不要作弊只检查长度！

## [未能遵循规则](https://thesquareplanet.com/blog/students-guide-to-raft/#failure-to-follow-the-rules)

虽然 Raft 论文非常明确如何实现每个 RPC 处理程序，但它将一些规则和不变量的实现留给未指定。这些列在图 2 右侧的"服务器规则"块中。虽然其中一些相当不言自明，但也有一些需要非常仔细地设计你的应用程序，以使其不违反规则：

* 如果在执行过程中的*任何时候* `commitIndex > lastApplied`，你应该应用特定的日志条目。立即执行它并不重要（例如，在 `AppendEntries` RPC 处理程序中），但*重要的是*你要确保这个应用只由一个实体完成。具体来说，你要么需要一个专用的"应用者"，要么在这些应用周围加锁，这样其他例程也不会检测到需要应用的条目并尝试应用。
* 确保你要么定期检查 `commitIndex > lastApplied`，要么在 `commitIndex` 更新后（即在 `matchIndex` 更新后）检查。例如，如果你在向对等方发送 `AppendEntries` 的同时检查 `commitIndex`，你可能需要等到*下一个*条目附加到日志才能应用你刚发送出去并获得确认的条目。
* 如果领导者发送 `AppendEntries` RPC，它被拒绝，但*不是因为日志不一致*（这只有在我们的任期已经过去时才会发生），那么你应该立即退位，*不更新* `nextIndex`。如果你这样做，如果你立即重新当选，你可能与 `nextIndex` 的重置产生竞争。
* 领导者不允许将 `commitIndex` 更新到*先前*任期（或者就此而言，未来任期）的某个位置。因此，正如规则所说，你需要专门检查 `log[N].term == currentTerm`。这是因为 Raft 领导者不能确定一个条目实际上已提交（并且将来不会改变），如果它不是来自他们当前任期的话。论文中的图 8 说明了这一点。

一个常见的混淆来源是 `nextIndex` 和 `matchIndex` 之间的区别。特别是，你可能观察到 `matchIndex = nextIndex - 1`，而干脆不实现 `matchIndex`。这是不安全的。虽然 `nextIndex` 和 `matchIndex` 通常同时更新为相似的值（具体来说，`nextIndex = matchIndex + 1`），但两者服务于完全不同的目的。`nextIndex` 是领导者与给定跟随者共享的前缀的*猜测*。它通常相当乐观（我们共享所有内容），只在否定响应时向后移动。例如，当领导者刚刚被选举时，`nextIndex` 被设置为日志末尾的索引。在某种程度上，`nextIndex` 用于性能——你只需要向这个对等方发送这些东西。

`matchIndex` 用于安全性。它是领导者与给定跟随者共享的日志前缀的保守*测量*。`matchIndex` 永远不能设置得太高，因为这可能导致 `commitIndex` 移动得太远。这就是为什么 `matchIndex` 初始化为 -1（即，我们在没有前缀上达成一致），并且只有在跟随者*积极确认* `AppendEntries` RPC 时才更新。

## [任期混淆](https://thesquareplanet.com/blog/students-guide-to-raft/#term-confusion)

任期混淆指的是服务器被来自旧任期的 RPC 搞糊涂了。一般来说，接收 RPC 时这不是问题，因为图 2 中的规则确切说明了当你看到旧任期时应该做什么。然而，图 2 通常不讨论当你收到旧的 RPC *回复*时应该做什么。根据经验，我们发现最简单的方法是首先记录回复中的任期（它可能比你当前的任期高），然后将当前任期与你原始 RPC 中发送的任期进行比较。如果两者不同，丢弃回复并返回。*只有*当两个任期相同时，你才应该继续处理回复。在这里你可能通过一些巧妙的协议推理做进一步的优化，但这种方法似乎工作得很好。而*不这样做*会导致一条漫长、曲折的鲜血、汗水、泪水和绝望的道路。

一个相关但不完全相同的问题是假设你的状态在发送 RPC 和收到回复之间没有改变。一个好的例子是在收到 RPC 回复时设置 `matchIndex = nextIndex - 1` 或 `matchIndex = len(log)`。这是*不安全的*，因为这两个值可能自你发送 RPC 以来已经更新。相反，正确的做法是将 `matchIndex` 更新为你原始在 RPC 中发送的参数中的 `prevLogIndex + len(entries[])`。

## [关于优化的旁白](https://thesquareplanet.com/blog/students-guide-to-raft/#an-aside-on-optimizations)

Raft 论文包括几个有趣的可选功能。在 6.824 中，我们要求学生实现其中的两个：日志压缩（第 7 节）和加速日志回溯（第 8 页左上角）。前者是避免日志无限增长所必需的，后者对于快速更新陈旧的跟随者很有用。

这些功能不是"核心 Raft"的一部分，因此在论文中没有像主要共识协议那样受到关注。日志压缩讨论得相当彻底（在图 13 中），但遗漏了一些你可能过于随意阅读时会错过的一些设计细节：

* 在快照应用程序状态时，你需要确保应用程序状态对应于 Raft 日志中某个已知索引之后的状态。这意味着应用程序要么需要向 Raft 传达快照对应的索引，要么 Raft 需要延迟应用额外的日志条目，直到快照完成。
* 文本没有讨论现在涉及快照时服务器崩溃并恢复的恢复协议。特别是，如果 Raft 状态和快照是分开提交的，服务器可能在持久化快照和持久化更新的 Raft 状态之间崩溃。这是一个问题，因为图 13 中的步骤 7 规定快照覆盖的 Raft 日志*必须被丢弃*。
  如果当服务器恢复时，它读取更新的快照，但日志过时，它可能最终应用一些*已经包含在快照中*的日志条目。发生这种情况是因为 `commitIndex` 和 `lastApplied` 没有被持久化，所以 Raft 不知道那些日志条目已经被应用。解决这个问题的方法是为 Raft 引入一个持久状态片段，记录 Raft 持久化日志中第一个条目对应的"真实"索引。然后可以将其与加载的快照的 `lastIncludedIndex` 进行比较，以确定丢弃日志开头的哪些元素。

加速日志回溯优化非常不够具体，可能是因为作者认为它对大多数部署不是必需的。从文本中不清楚从客户端返回的冲突索引和任期应该由领导者用来确定使用什么 `nextIndex`。我们认为作者*可能*希望你遵循的协议是：

* 如果跟随者的日志中没有 `prevLogIndex`，它应该返回 `conflictIndex = len(log)` 和 `conflictTerm = None`。
* 如果跟随者的日志中确实有 `prevLogIndex`，但任期不匹配，它应该返回 `conflictTerm = log[prevLogIndex].Term`，然后在其日志中搜索第一个其条目任期等于 `conflictTerm` 的索引。
* 收到冲突响应后，领导者应该首先在其日志中搜索 `conflictTerm`。如果它在日志中找到具有该任期的条目，它应该将 `nextIndex` 设置为其日志中该任期最后一个条目索引之后的那个。
* 如果它没有找到具有该任期的条目，它应该设置 `nextIndex = conflictIndex`。

一个折衷的解决方案是只使用 `conflictIndex`（并忽略 `conflictTerm`），这简化了实现，但领导者有时最终会向跟随者发送更多的日志条目，比严格需要更新它们的要多。

# [在 Raft 之上的应用程序](https://thesquareplanet.com/blog/students-guide-to-raft/#applications-on-top-of-raft)

当在 Raft 之上构建服务时（如[第二个 6.824 Raft 实验](https://pdos.csail.mit.edu/6.824/labs/lab-kvraft.html)中的键值存储），服务与 Raft 日志之间的交互可能很难正确处理。本节详细说明了开发过程的一些方面，你在构建应用程序时可能会发现有用。

## [应用客户端操作](https://thesquareplanet.com/blog/students-guide-to-raft/#applying-client-operations)

你可能对如何甚至基于复制日志实现应用程序感到困惑。你可能开始让你的服务在收到客户端请求时，将该请求发送给领导者，等待 Raft 应用某些东西，执行客户端要求的操作，然后返回给客户端。虽然在单客户端系统中这没问题，但它不适用于并发客户端。

相反，服务应该构建为*状态机*，其中客户端操作将机器从一个状态转换到另一个状态。你应该在某处有一个循环，一次接收一个客户端操作（在所有服务器上以相同顺序——这就是 Raft 的用武之地），并按顺序将每个操作应用于状态机。这个循环应该是你代码中*唯一*接触应用程序状态（6.824 中的键值映射）的部分。这意味着你的面向客户端的 RPC 方法应该简单地将客户端的操作提交给 Raft，然后*等待*该操作被这个"应用循环"应用。只有当客户端的命令出现时才应该执行它，并读取任何返回值。注意*这包括读请求*！

这引出了另一个问题：你如何知道客户端操作何时完成？在没有故障的情况下，这很简单——你只是等待你放入日志的东西回来（即，被传递给 `apply()`）。当这种情况发生时，你将结果返回给客户端。然而，如果有故障会发生什么？例如，当客户端最初联系你时你可能是领导者，但其他人后来被选举，你放入日志的客户端请求已被丢弃。显然你需要让客户端重试，但你如何知道何时告诉他们错误？

解决这个问题的简单方法是记录客户端操作在 Raft 日志中出现的位置。一旦该索引处的操作被发送到 `apply()`，你可以根据为该索引出现的操作实际上是你放入的那个操作来判断客户端的操作是否成功。如果不是，则发生了故障，可以向客户端返回错误。

## [重复检测](https://thesquareplanet.com/blog/students-guide-to-raft/#duplicate-detection)

一旦你让客户端在错误面前重试操作，你就需要某种重复检测方案——如果客户端向你的服务器发送 `APPEND`，没有听到回复，然后重新发送到下一个服务器，你的 `apply()` 函数需要确保 `APPEND` 不会被执行两次。为此，你需要某种唯一的标识符为每个客户端请求，这样你可以识别过去是否看到过，更重要的是，应用过特定的操作。此外，这种状态需要成为你状态机的一部分，这样你的所有 Raft 服务器都消除*相同*的重复。

有许多分配此类标识符的方法。一个简单且相当高效的方法是给每个客户端一个唯一标识符，然后让他们用单调递增的序列号标记每个请求。如果客户端重新发送请求，它重用相同的序列号。你的服务器跟踪为每个客户端看到的最新序列号，并简单地忽略它已经看到的任何操作。

## [棘手的边界情况](https://thesquareplanet.com/blog/students-guide-to-raft/#hairy-corner-cases)

如果你的实现遵循上面给出的一般大纲，你至少可能遇到两个微妙的问题，没有一些严肃的调试可能很难识别。为了节省你一些时间，这里是它们：

 **重新出现的索引**：假设你的 Raft 库有一些方法 `Start()`，它接受一个命令，并返回该命令在日志中放置的索引（这样你就知道何时返回给客户端，如上所述）。你可能假设你永远不会看到 `Start()` 返回相同的索引两次，或者至少，如果你再次看到相同的索引，首先返回该索引的命令必定已经失败。事实证明，即使没有服务器崩溃，这两件事都不是真的。

考虑以下有五个服务器 S1 到 S5 的场景。最初，S1 是领导者，其日志为空。

1. 两个客户端操作（C1 和 C2）到达 S1
2. `Start()` 为 C1 返回 1，为 C2 返回 2。
3. S1 向 S2 发送包含 C1 和 C2 的 `AppendEntries`，但其所有其他消息都丢失了。
4. S3 作为候选者向前推进。
5. S1 和 S2 不会投票给 S3，但 S3、S4 和 S5 都会，所以 S3 成为领导者。
6. 另一个客户端请求 C3 到达 S3。
7. S3 调用 `Start()`（返回 1）
8. S3 向 S1 发送 `AppendEntries`，S1 从其日志中丢弃 C1 和 C2，并添加 C3。
9. S3 在向任何其他服务器发送 `AppendEntries` 之前失败。
10. S1 向前推进，由于其日志是最新的，它被选举为领导者。
11. 另一个客户端请求 C4 到达 S1
12. S1 调用 `Start()`，返回 2（这也是 `Start(C2)` 返回的）。
13. S1 的所有 `AppendEntries` 都被丢弃，S2 向前推进。
14. S1 和 S3 不会投票给 S2，但 S2、S4 和 S5 都会，所以 S2 成为领导者。
15. 客户端请求 C5 到达 S2
16. S2 调用 `Start()`，返回 3。
17. S2 成功向所有服务器发送 `AppendEntries`，S2 通过在下一个心跳中包含更新的 `leaderCommit = 3` 向服务器报告。

由于 S2 的日志是 `[C1 C2 C5]`，这意味着在索引 2 处提交（并在所有服务器，包括 S1 上应用）的条目是 C2。尽管 C4 是最后一个在 S1 返回索引 2 的客户端操作。

 四方死锁：找到这个问题的所有功劳都归于 [Steven Allen](http://stebalien.com/)，另一个 6.824 教学助理。他发现了以下令人讨厌的四方死锁，你在 Raft 之上构建应用程序时很容易陷入。

 你的 Raft 代码，无论其结构如何，很可能有一个类似 `Start()` 的函数，允许应用程序向 Raft 日志添加新命令。它很可能还有一个循环，当 `commitIndex` 更新时，在日志中 `lastApplied` 和 `commitIndex` 之间的每个元素上调用应用程序的 `apply()`。这些例程可能都需要一些锁 `a`。在你基于 Raft 的应用程序中，你可能在你 RPC 处理程序的某个地方调用 Raft 的 `Start()` 函数，并且你在其他地方有代码，当 Raft 应用新的日志条目时会被通知。由于这两个需要通信（即，RPC 方法需要知道它放入日志的操作何时完成），它们都可能需要一些锁 `b`。

在 Go 中，这四个代码段可能看起来像这样：


```go
func (a *App) RPC(args interface{}, reply interface{}) {
    // ...
    a.mutex.Lock()
    i := a.raft.Start(args)
    // 更新一些数据结构，以便 apply 知道稍后通知我们
    a.mutex.Unlock()
    // 等待 apply 通知我们
    return
}
```

```go
func (r *Raft) Start(cmd interface{}) int {
    r.mutex.Lock()
    // 做一些事情来开始对这个新命令达成一致
    // 存储命令在日志中放置的索引
    r.mutex.Unlock()
    return index
}
```

```go
func (a *App) apply(index int, cmd interface{}) {
    a.mutex.Lock()
    switch cmd := cmd.(type) {
    case GetArgs:
        // 执行 get 操作
	// 查看谁在监听这个索引
	// 用操作结果通知他们所有
    // ...
    }
    a.mutex.Unlock()
}
```

```go
func (r *Raft) AppendEntries(...) {
    // ...
    r.mutex.Lock()
    // ...
    for r.lastApplied < r.commitIndex {
      r.lastApplied++
      r.app.apply(r.lastApplied, r.log[r.lastApplied])
    }
    // ...
    r.mutex.Unlock()
}
```

现在考虑系统是否处于以下状态：

* `App.RPC` 刚刚获取了 `a.mutex` 并调用了 `Raft.Start`
* `Raft.Start` 正在等待 `r.mutex`
* `Raft.AppendEntries` 正在持有 `r.mutex`，并刚刚调用了 `App.apply`

我们现在有了死锁，因为：

* `Raft.AppendEntries` 在 `App.apply` 返回之前不会释放锁。
* `App.apply` 在获得 `a.mutex` 之前无法返回。
* `a.mutex` 在 `App.RPC` 返回之前不会被释放。
* `App.RPC` 在 `Raft.Start` 返回之前不会返回。
* `Raft.Start` 在获得 `r.mutex` 之前无法返回。
* `Raft.Start` 必须等待 `Raft.AppendEntries`。

有几种方法可以绕过这个问题。最简单的一种是在 `App.RPC` 中调用 `a.raft.Start` *之后*获取 `a.mutex`。然而，这意味着 `App.apply` 可能在 `App.RPC` 有机会记录它希望被通知的事实之前，就被 `App.RPC` 刚刚调用 `Raft.Start` 的操作调用。另一种可能产生更整洁设计的方案是让一个单一的、专用线程从 `Raft` 调用 `r.app.apply`。这个线程可以在每次 `commitIndex` 更新时被通知，然后就不需要持有锁来应用，从而打破死锁。