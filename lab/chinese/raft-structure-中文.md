Raft 结构建议

Raft 实例必须处理外部事件的到达（Start() 调用、AppendEntries 和 RequestVote RPC 以及 RPC 回复），并且必须执行定期任务（选举和心跳）。有很多方法可以构建你的 Raft 代码来管理这些活动；本文档概述了一些想法。

每个 Raft 实例都有一堆状态（日志、当前索引等），这些状态必须响应并发 goroutine 中产生的事件进行更新。Go 文档指出，goroutine 可以使用共享数据结构和锁直接执行更新，或者通过在通道上传递消息。经验表明，对于 Raft，使用共享数据和锁是最直接的方法。

Raft 实例有两个时间驱动的活动：领导者必须发送心跳，其他节点如果在太长时间没有听到领导者的消息，必须开始选举。最好用专用的长期运行 goroutine 来驱动这些活动中的每一个，而不是将多个活动组合到一个 goroutine 中。

选举超时的管理是一个常见的头疼问题。也许最简单的计划是在 Raft 结构中维护一个变量，包含对等方最后一次听到领导者消息的时间，并让选举超时 goroutine 定期检查自那时起的时间是否大于超时周期。使用带有小常量参数的 time.Sleep() 来驱动定期检查是最容易的。不要使用 time.Ticker 和 time.Timer；它们很难正确使用。

你需要一个单独的长期运行 goroutine，按顺序在 applyCh 上发送已提交的日志条目。它必须是分开的，因为在 applyCh 上发送可能会阻塞；而且它必须是单个 goroutine，否则可能很难确保你按日志顺序发送日志条目。推进 commitIndex 的代码需要启动应用 goroutine；使用条件变量（Go 的 sync.Cond）可能是最简单的。

每个 RPC 可能应该在它自己的 goroutine 中发送（并处理其回复），原因有两个：这样不可达的对等方不会延迟收集多数回复，并且心跳和选举定时器可以一直继续计时。在同一个 goroutine 中处理 RPC 回复最容易，而不是通过通道发送回复信息。

请记住，网络可能延迟 RPC 和 RPC 回复，当你发送并发 RPC 时，网络可以重新排序请求和回复。图 2 在指出 RPC 处理程序需要注意这种情况的地方（例如，RPC 处理程序应该忽略具有旧任期的 RPC）方面做得很好。图 2 对于 RPC 回复处理并不总是明确的。领导者在处理回复时必须小心；它必须检查任期自发送 RPC 以来是否没有改变，并且必须考虑到对同一跟随者的并发 RPC 回复可能已经改变了领导者的状态（例如 nextIndex）。